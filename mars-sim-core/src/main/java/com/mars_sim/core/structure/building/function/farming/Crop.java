/*
 * Mars Simulation Project
 * Crop.java
 * @date 2024-07-12
 * @author Scott Davis
 */
package com.mars_sim.core.structure.building.function.farming;

import java.util.Arrays;

import com.mars_sim.core.Entity;
import com.mars_sim.core.logging.SimLogger;
import com.mars_sim.core.person.Person;
import com.mars_sim.core.person.ai.task.util.Worker;
import com.mars_sim.core.resource.ItemResourceUtil;
import com.mars_sim.core.resource.ResourceUtil;
import com.mars_sim.core.structure.Settlement;
import com.mars_sim.core.structure.building.Building;
import com.mars_sim.core.time.ClockPulse;
import com.mars_sim.core.time.MarsTime;
import com.mars_sim.core.tool.RandomUtil;

/**
 * The Crop class describes the behavior of a crop growing on a greenhouse.
 */
public class Crop implements Comparable<Crop>, Entity {

	/** default serial id. */
	private static final long serialVersionUID = 1L;
	/** default logger. */
	private static SimLogger logger = SimLogger.getLogger(Crop.class.getName());
	
	/**
	 * The watt to photon conversion ratio on Mars as defined in crops.xml [in umol
	 * /m^2 /s /(Wm^-2)].
	 */
	private static double wattToPhotonConversionRatio;
	/**
	 * The converted value of the watt to photon conversion ratio on Mars as defined
	 * in crops.xml [in umol /m^2 /millisols /(Wm^-2)].
	 */
	private static double conversionFactor;
	/** The average water needed [in kg] */
	private static double averageWaterNeeded;
	/** The average O2 needed [in kg] */
	private static double averageOxygenNeeded;
	/** The average CO2 needed [in kg] */
	private static double averageCarbonDioxideNeeded;
	
	private static final int WATER_ID = ResourceUtil.waterID;
	private static final int OXYGEN_ID = ResourceUtil.oxygenID;
	private static final int CO2_ID = ResourceUtil.co2ID;
	private static final int GREY_WATER_ID = ResourceUtil.greyWaterID;
	private static final int CROP_WASTE_ID = ResourceUtil.cropWasteID;
	private static final int FERTILIZER_ID = ResourceUtil.fertilizerID;
	private static final int MUSHROOM_BOX_ID = ItemResourceUtil.findIDbyItemResourceName("mushroom containment kit");

	private static final int LIGHT_FACTOR = 0;
	private static final int FERTILIZER_FACTOR = 1;
	private static final int TEMPERATURE_FACTOR = 2;
	
	private static final int WATER_FACTOR = 3;
	private static final int O2_FACTOR = 4;
	private static final int CO2_FACTOR = 5;
	/** How often to calculate the crop health */
	private static final int CHECK_HEALTH_FREQUENCY = 8;
	
	/** The modifier for the work time on a crop. */
	private static final double WORK_TIME_FACTOR = 4000.0;
	
	/** The modifier for the work time on a crop. */
	private static final int WORK_FACTOR = 20;
	
	/** The rate of taking care of the health of the crop. */
	private static final double RECOVER_HEALTH_RATE = .5;
	
	/** The minimum time offset [in millisols] for a crop that requires work. */
	public static final double CROP_RESILIENCY = -100;
	
	public static final double POSITIVE_ENTROPY = 0;
	
	// Future: Move params into crops.xml and load from CropConfig
	/** How often are the crops checked in mSols */
	private static final double CHECK_CROP_PERIOD = 4;

	private static final double TUNING_FACTOR = 3.5;
	
	private static final double GAS_MODIFIER = 1.5;
	
	private static final double WATER_MODIFIER = 1.1;

	private static final int PETRI_DISH_ID = ItemResourceUtil.findIDbyItemResourceName("petri dish");

	
	/**
	 * The limiting factor that determines how fast and how much PAR can be absorbed
	 * in one frame.
	 * Note: 1 is max. if set to 1, a lot of lights will toggle on and off undesirably.
	 */
	private static final double PHYSIOLOGICAL_LIMIT = 0.9; 
	
	private static final double RATIO_LEAVES = .75;

	/** The average amount of new soil needed needed per square meters. */
	public static final double NEW_SOIL_NEEDED_PER_SQM = .2D;
	/**
	 * The average amount of fertilizers needed when watering (but not needed if
	 * supplied with grey water).
	 */
	public static final double FERTILIZER_NEEDED_WATERING = 0.001;
	/**
	 * The average amount of fertilizers needed per square meter when planting a new
	 * crop.
	 */
	public static final double FERTILIZER_NEEDED_IN_SOIL_PER_SQM = 0.1;

	/**
	 * The ratio of oxygen to carbon during the day when photosynthesis is taking
	 * place and CO2 is absorbed and O2 is generated by the crop.
	 */
	private static final double O2_TO_CO2_RATIO = 44 / 32D;
	/**
	 * The rate of carbon dioxide to oxygen during night time when O2 is absorbed
	 * and CO2 is released by the crop.
	 * <p> Note: 6CO2 --> 6O2 since
	 * <p> 6nCO2 + 5nH2O ⇒ (C6H10O5)n + 6nO2
	 */
	private static final double CO2_TO_O2_RATIO = 32 / 44D; 
	
	/** SurfaceFeatures.MEAN_SOLAR_IRRADIANCE * 4.56 * (not 88775.244)/1e6 = 237.2217 */
	// public static final double MEAN_DAILY_PAR = 237.2217D ; // in [umol/m2/day]
	
	/** The wattage of a 400W high pressure sodium (HPS) lamp. */
	private static final double KW_PER_HPS = .4;
	/** The lamp efficiency of the high pressure sodium (HPS) lamp. */
	private static final double VISIBLE_RADIATION_HPS = 0.4;
	/** The ballast loss of the high pressure sodium (HPS) lamp. */
	private static final double BALLAST_LOSS_HPS = 0.1;
	/** The non-visible radiation loss of the high pressure sodium (HPS) lamp. */
	private static final double NON_VISIBLE_RADIATION_HPS = .37;
	/** The conduction convection loss of the high pressure sodium (HPS) lamp. */
	private static final double CONDUCTION_CONVECTION_HPS = .13;
	/** The total loss of the high pressure sodium (HPS) lamp. */
	public static final double LOSS_FACTOR_HPS = NON_VISIBLE_RADIATION_HPS * .75 + CONDUCTION_CONVECTION_HPS / 2D;
	/** The minimal amount of resource to be retrieved. */
	private static final double MIN = 0.001;
	
	private static final double COMBINED_LAMP_FACTOR = KW_PER_HPS * VISIBLE_RADIATION_HPS 
			* (1 - BALLAST_LOSS_HPS) / PHYSIOLOGICAL_LIMIT;

	/** The string reference for mushroom */
	private static final String MUSHROOM = "mushroom";

	// Data members
	/** True if this crop is generated at the start of the sim . */
	private boolean isStartup;
	/** The crop identifier (unique only within a greenhouse). */
	private int identifier;
	/** The total amount of light received by this crop. */
	private double effectivePAR;
	/** The ratio between inedible and edible biomass */
	private double massRatio;
	/** The maximum possible harvest for this crop [in kg]. */
	private double maxHarvest;
	/** The remaining possible harvest for this crop [in kg]. */
	private double remainingHarvest;
	/** The completed work time in current phase [in millisols]. */
	private double currentPhaseWorkCompleted = 0;
	/** The current work time required [in millisols]. */
	private double currentWorkRequired = RandomUtil.getRandomDouble(0, 10);
	/** The daily harvest for crop [in kg/per sol]. */
	private double dailyHarvest;
	/** The total amount harvested [in kg]. */
	private double totalHarvest;
	/** The growing phase time completed thus far [in millisols]. */
	private double growingTimeCompleted;
	/** Percentage of growing completed */
	private double percentageGrowth;
	/** The area occupied by the crop in square meters. */
	private double growingArea;
	/** The cumulative value of the daily PAR so far. */
	private double cumulativeDailyPAR = 0;
	/** The required power for lighting [in kW]. */
	private double lightingPower = 0;
	/** The health condition factor of the crop. 1 = excellent. 0 = worst*/
	private double healthCondition = 1;


	/** The disease index of a crop. */
	private double diseaseIndex = 0;
	/** The cache for co2. */
	private double co2Cache = 0;
	/** The cache for o2. */	
	private double o2Cache = 0;
	/** The time accumulated [in millisols] for each crop update call. */
	private double accumulatedTime = RandomUtil.getRandomDouble(0, 1.0);
	/** The threshold for tracking a gas [in kg] */
	private final double gasThreshold;
	
	/** The cache values of the past environment factors influencing the crop */
	private double[] environmentalFactor = new double[CO2_FACTOR + 1];

	private String name;

	private CropSpec cropSpec;

	/** Current phase of crop. */
	private Phase currentPhase;

	private Farming farm;
	private Building building;

	/**
	 * Constructor.
	 *
	 * @param identifier      the identifier of this crop.
	 * @param cropType        the type of crop.
	 * @param growingArea     the area occupied by the crop [m^2]
	 * @param dailyMaxHarvest - Maximum possible food harvest for crop. (kg/sol)
	 * @param farm            - Farm crop being grown in.
	 * @param isStartup       - true if this crop is generated at the start of the
	 *                        sim)
	 * @param tissuePercent   the percentage of ticarbonDioxideIDure available based
	 *                        on the requested amount
	 */
	public Crop(int identifier, CropSpec cropType, double growingArea, double dailyMaxHarvest, Farming farm,
			boolean isStartup, double tissuePercent) {

		this.identifier = identifier;
		this.cropSpec = cropType;
		this.growingArea = growingArea;
		this.farm = farm;
		this.isStartup = isStartup;
		this.gasThreshold = growingArea/10.0;
		this.name = cropSpec.getName();
		
		// Set up env factor to be balanced
		Arrays.fill(environmentalFactor, 1D);

		building = farm.getBuilding();

		double growingDay = cropType.getGrowingSols();
		double growingTime = growingDay * 1000D;

		maxHarvest = dailyMaxHarvest * growingDay;
		// Set to zero initially
		remainingHarvest = 0;

		if (cropSpec.getSeedID() > 0) {
			massRatio = 1;
		}
		
		PhaseType phaseType;
		if (!isStartup) {
			// if this is not a grown crop at the start of the sim, start from the beginning

			if (tissuePercent <= 0) {
				// assume a max 2-day incubation period if no 0% tissue culture is available
				phaseType = PhaseType.INCUBATION;
				currentPhaseWorkCompleted = 0;
				// Need a petri dish
				if (building.getSettlement().hasItemResource(PETRI_DISH_ID)) {
					building.getSettlement().retrieveItemResource(PETRI_DISH_ID, 1);
				}
				else
					logger.warning(this, 60_000, "No petri dish left for growing " + cropSpec.getName()
						+ " tissue-culture.");
			}

			else if (tissuePercent >= 100) {
				// assume zero day incubation period if 100% tissue culture is available
				phaseType = PhaseType.PLANTING;
				currentPhaseWorkCompleted = 0;
				logger.info(this, "Done growing its tissue-culture. Transferring plantflets to the field.");

				// if it's growing mushroom
				if (name.toLowerCase().contains(MUSHROOM)) {
					setupMushroom();
				}
			}

			else {
				phaseType = PhaseType.INCUBATION;
				currentPhaseWorkCompleted = 1000D * cropSpec.getCropCategory().getPhase(phaseType).getWorkRequired() * (100D - tissuePercent) / 100D;
				logger.info(this, "A work period of "
								+ Math.round(currentPhaseWorkCompleted / 1000D * 10D) / 10D
								+ " sols is needed to clone enough tissues before planting.");
			}
		}

		else {
			// This is a grown crop at the start of the sim,
			// Set the percentage of growth randomly
			growingTimeCompleted = RandomUtil.getRandomDouble(growingTime * .99);

			percentageGrowth = (growingTimeCompleted * 100D) / growingTime;

			// Fast track through the phases
			var category = cropSpec.getCropCategory();
			var phases = category.getPhases();
			Phase startingPhase = null;
			for(Phase phase : phases) {
				if (phase.getCumulativePercentGrowth() > percentageGrowth) {
					startingPhase = phase;
					break;
				}
			}

			phaseType = startingPhase.getPhaseType();
			currentPhaseWorkCompleted = 1000D * startingPhase.getWorkRequired();
					
			// Future: how to allow crops such as cilantro to be harvested early to collect leaves, 
			// instead of waiting for seeds (coriander) to be matured ?
			
			// Set the daily harvest
			dailyHarvest = dailyMaxHarvest;
			// Set the remaining harvest based on percentageGrowth
			remainingHarvest = (maxHarvest * percentageGrowth)/100D;
		}

		updatePhase(phaseType);
	}

	/**
	 * Updates the current phase to a new type.
	 * 
	 * @param phaseType
	 */
	private void updatePhase(PhaseType phaseType) {
		currentPhase = cropSpec.getCropCategory().getPhase(phaseType);
	}

	/**
	 * Sets up mushroom.
	 */
	private void setupMushroom() {
		Settlement s = building.getSettlement();
		if (s.hasItemResource(MUSHROOM_BOX_ID)) {
			s.retrieveItemResource(MUSHROOM_BOX_ID, 1);
		}
		// Need a petri dish
		if (s.hasItemResource(PETRI_DISH_ID)) {
			s.retrieveItemResource(PETRI_DISH_ID, 1);
		}
		else
			logger.warning(this, 60_000, 
					"No petri dish left for isolating its tissues.");
		// Require some dead matter for fungi to decompose
		if (growingArea * .2 > MIN)
			retrieve(growingArea * .2, CROP_WASTE_ID, true);
	}

	public double getLightingPower() {
		return lightingPower;
	}

	public double getGrowingArea() {
		return growingArea;
	}

	/**
	 * Gets the crop spec that defines this Crop.
	 *
	 * @return crop type ID
	 */
	public CropSpec getCropSpec() {
		return cropSpec;
	}

	/**
	 * Gets the crop name.
	 *
	 * @return crop name
	 */
	public String getCropName() {
		return name;
	}

	/**
	 * Gets the phase type of the crop.
	 *
	 * @return phaseType
	 */
	public PhaseType getPhaseType() {
		return currentPhase.getPhaseType();
	}

	/**
	 * Sets the current phase to harvesting.
	 */
	public void setToHarvest() {
		boolean isDone = false;
		while (!isDone) {
			// Advance forward one growing phase
			advancePhase();
			if (currentPhase.getPhaseType() == PhaseType.HARVESTING) {
				isDone = true;
			}
		}
	}
	
	/**
	 * Gets the maximum possible food harvest for crop.
	 *
	 * @return food harvest (kg.)
	 */
	public double getMaxHarvest() {
		return maxHarvest;
	}

	/**
	 * Gets the amount of growing time completed.
	 *
	 * @return growing time (millisols)
	 */
	public double getGrowingTimeCompleted() {
		return growingTimeCompleted;
	}

	/**
	 * Gets the amount of growing time completed.
	 *
	 * @return growing time (millisols)
	 */
	public double getCurrentPhaseWorkCompleted() {
		return currentPhaseWorkCompleted;
	}
	
	/**
	 * Gets the current work required.
	 * 
	 * @return
	 */
	public double getCurrentWorkRequired() {
		return currentWorkRequired;
	}
	
	/**
	 * Checks if crop needs additional work on current sol.
	 *
	 * @return true if more work needed.
	 */
	public boolean requiresWork() {
		// Note that harvesting phase works differently
		if (currentPhase.getPhaseType() == PhaseType.HARVESTING
				|| currentPhase.getPhaseType() == PhaseType.PLANTING
				|| currentPhase.getPhaseType() == PhaseType.INCUBATION
				)
			return true;
		
		return currentWorkRequired > POSITIVE_ENTROPY ;
	}

	/**
	 * Gets the priority score for this crop based on the phase.
	 */
	public double getTendingScore() {
		double score = 0;
		if (currentWorkRequired > POSITIVE_ENTROPY) {
			score = (int)Math.floor(currentWorkRequired / 15); 
		}
		return switch(currentPhase.getPhaseType()) {
			case HARVESTING -> score * 3;
			case PLANTING -> score * 1;
			case INCUBATION -> score * 1.5;
			default -> score * 2;
		};
	}

	/**
	 * Tracks the overall health condition of the crop.
	 * 
	 * @return condition as value from 0 (poor) to 1 (healthy)
	 */
	private double trackHealth() {
		double health;

		switch(currentPhase.getPhaseType()) {
		case INCUBATION, PLANTING:
			health = 1D;
			break;

		case GERMINATION:
			if (percentageGrowth <= 5D) {
				// avoid initial spurious data at the start of the sim
				health = 1D;
			}
			else {
				health = calculateHealth();
			}
			break;

		default:
			health = calculateHealth();
			break;
		}
		
		if (health > 1D)
			health = 1D;
		else if (health < 0D)
			health = 0D;

		if (percentageGrowth > 10D) {
			// Check on the health of a >10% growing crop
			if (health < .05) {
				logger.warning(this, 10_000, 
						"At " + Math.round(percentageGrowth * 10D)/10D 
						+ " percent of growth, it died of very poor health (" + Math.round(health * 100D) / 1D + " %).");
				// Add Crop Waste
				double amt = percentageGrowth * remainingHarvest / 100D;
				if (amt > 0) {
					store(amt, CROP_WASTE_ID);
					logger.warning(this, 10_000, 
							Math.round(amt * 10D)/10D  + " kg crop waste generated.");
				}
				updatePhase(PhaseType.FINISHED);
			}
		}

		else { // fractionalGrowthCompleted < .1 && fractionalGrowthCompleted > 0D
				// Seedling (<10% grown crop) is less resilient and more prone to environmental
				// factors
			if (health < .1) {
				logger.warning(this, 10_000, "Seedlings at " 
						+ Math.round(percentageGrowth * 10D)/10D 
						+ " % growth unable to survive due to very poor health ("
						+ Math.round(health * 100D) / 1D + " %).");
				// Add Crop Waste
				double amt = percentageGrowth * remainingHarvest / 100;
				if (amt > 0) {
					store(amt, CROP_WASTE_ID);
					logger.warning(this, 10_000, 
							Math.round(amt * 100D) / 100D  + " kg crop waste generated.");
				}
				updatePhase(PhaseType.FINISHED);
			}
		}

		// set healthCondition so that it can be accessed outside of this class
		healthCondition = health;

		return health;
	}

	/*
	 * Computes the health of a crop.
	 */
	private double calculateHealth() {
		double health = 0;
		double total = 0;
		int size = environmentalFactor.length;
		boolean needsLight = cropSpec.needsLight();
		for (int i=0; i< size; i++) {
			if (!needsLight && (i == LIGHT_FACTOR)) {
					total = total + 1;  // Ignore environmental factor
			}
			else {
				total = total + environmentalFactor[i];
			}
		}
		
		// Future: will need to model diseaseIndex
		
		double workTimeFactor = 0;
		if (currentWorkRequired < 10)
			// Within 100 is still considered well taken care of
			workTimeFactor = (10 - currentWorkRequired) / WORK_TIME_FACTOR;
		else
			// Beyond 100 will incur penalty
			// The negative sign creates penalty to crop health
			workTimeFactor = - (currentWorkRequired - 1000) / WORK_TIME_FACTOR;
		
		health = (1 - diseaseIndex) * total / size + workTimeFactor;

		if (health > 1)
			health = 1;
		else if (health < 0)
			health = 0;

		return health;
	}

	/**
	 * Adds work time to the crops current phase.
	 *
	 * @param workTime - Work time to be added (millisols)
	 * @return workTime remaining after working on crop (millisols)
	 * @throws Exception if error adding work.
	 */
	public double addWork(Worker worker, double workTime) {
		double modTime = workTime * WORK_FACTOR;
		// Note: it's important to set remainingTime initially to zero. If not, addWork will be in endless while loop
		double remainingTime = 0;
		// Record the work time in Farming
		farm.addCumulativeWorkTime(workTime);
		// Reduce the work required
		currentWorkRequired -= modTime;
		// Note: Allow the plant to be over-tended (thus currentWorkRequired becomes negative) 
		// so that it won't need to be taken care of for a while
		
		// Improve the health of the crop each time it's being worked on
		healthCondition += RECOVER_HEALTH_RATE * modTime;
		if (healthCondition > 1)
			healthCondition = 1;

		double phaseWorkReqMillisols = currentPhase.getWorkRequired() * 1000D;

		if (dailyHarvest < 0D) {
			dailyHarvest = 0;
			growingTimeCompleted = 0;
		}

		// Only do phases that need manual work
		PhaseType phaseType = currentPhase.getPhaseType();
		switch (phaseType) {
		case INCUBATION, PLANTING:
			// At a particular growing phase (NOT including the harvesting phase)
			currentPhaseWorkCompleted += modTime;
			
			if (currentPhaseWorkCompleted >= phaseWorkReqMillisols * 1.01) {
				currentPhaseWorkCompleted = 0;
				advancePhase();
				logger.fine(this, "Entered a new phase " + currentPhase.getPhaseType()
						+ "   Phase Work Completed : " + Math.round(currentPhaseWorkCompleted * 10D) / 10D
						+ "   Phase Work Required : " + Math.round(phaseWorkReqMillisols * 10D) / 10D);
			}
			break;

		case MATURATION, HARVESTING:
			// at the maturation or harvesting phase
			currentPhaseWorkCompleted += modTime;
			// Set the harvest multiplier
			int multiplier = 5;

			if (currentPhaseWorkCompleted >= phaseWorkReqMillisols * 1.01) {
				// Modify parameter list to include crop name
				double lastHarvest = multiplier * dailyHarvest * modTime/ phaseWorkReqMillisols;

				if (remainingHarvest > 0) {
					collectProduce(lastHarvest);

					remainingHarvest -= lastHarvest;
					totalHarvest += lastHarvest;

					// Don't end until there is nothing left ?
					if (remainingHarvest <= 0) {
						String phaseDescription = "";
						if (phaseType == PhaseType.MATURATION)
							phaseDescription = " during the initial harvest.";
						else if (phaseType == PhaseType.HARVESTING)
							phaseDescription = " during the final harvest.";

						logger.info(this, 4_000, 
								"Harvested a total of "
									+ Math.round(totalHarvest * 100.0) / 100.0 + " kg."
									+ phaseDescription);

						// Reset the totalHarvest back to zero.
						totalHarvest = 0;
						// Sets the phase to FINISHED
						updatePhase(PhaseType.FINISHED);

						//  Check to see if a botany lab is available
						if (worker instanceof Person && !farm.checkBotanyLab())
							logger.warning(worker,
									"Can't find an available lab bench to work on its tissue culture.");
					}
				}
			}
			else {
				if (dailyHarvest > 0.00001) {
					// Continue the harvesting process
					double modifiedHarvest = multiplier * dailyHarvest * modTime / phaseWorkReqMillisols;
					// Store the crop harvest
					if (modifiedHarvest > 0 && remainingHarvest > 0) {
						collectProduce(modifiedHarvest);
						remainingHarvest -= modifiedHarvest;
						totalHarvest += modifiedHarvest;
					}
				}
			}
			break;

		case FINISHED:
			// Shouldn't be here
			break;

		default:
			// at a particular growing phase (NOT including the harvesting phase)
			currentPhaseWorkCompleted += modTime;

			if (currentPhaseWorkCompleted >= phaseWorkReqMillisols * 1.01) {
				currentPhaseWorkCompleted = 0D;
			}
			break;
		}

		// Safety check
		if ((currentPhase.getPhaseType() == PhaseType.HARVESTING) && percentageGrowth > 115D)  {
			logger.fine(this, "At " + percentageGrowth
					   + "% of growth, setting the phase to FINISHED.");
			updatePhase(PhaseType.FINISHED);
		}

		return remainingTime;
	}

	/**
	 * Advances the crop to the next phase of growth.
	 */
	private void advancePhase() {
		currentPhase = cropSpec.getCropCategory().getNextPhase(currentPhase);
		currentPhaseWorkCompleted = 0;
	}
	
	
	/**
	 * Collects the produce during harvest.
	 * 
	 * @param harvestMass
	 */
	private void collectProduce(double harvestMass) {
		boolean isSeedPlant = cropSpec.isSeedPlant();
		int seedID = cropSpec.getSeedID();
		int cropID = cropSpec.getCropID();
		
		if (isSeedPlant) {
			// Extract Sesame Seed.
			// Note the purpose for this plant is primarily the seeds
			// Future: how best to handle Peanut ?
			// Is peanut considered a seed plant ?			
			store(harvestMass, seedID);
		}
		else if ((seedID > 0) && harvestMass * massRatio > 0) {
			// Cilantro & White Mustard has leaves as food. 
			// White Mustard makes mustard seed
			// Cilantro makes coriander seed
			store(harvestMass * massRatio, seedID);
			store(harvestMass, cropID);
		}
		else {
			store(harvestMass, cropID);
		}

		// Calculate the amount of leaves and crop wastes that are generated
		double inedible = harvestMass / cropSpec.getEdibleBiomass() * cropSpec.getInedibleBiomass();
		double cropWaste = inedible * RandomUtil.getRandomDouble(RATIO_LEAVES);
		if (cropWaste > 0) {
			store(cropWaste, CROP_WASTE_ID);
		}

		if (cropSpec.getCropCategory().getName().equalsIgnoreCase("Leaves")) {
			double leaves = inedible - cropWaste;
			if (leaves > 0) {
				store(leaves, ResourceUtil.leavesID);
			}
		}
	}

	/**
	 * Time passing for crop.
	 * 
	 * @param pulse
	 * @param productionLevel
	 * @param solarIrradiance
	 * @param greyFilterRate
	 * @param temperatureModifier
	 *
	 * @return
	 */
	public boolean timePassing(ClockPulse pulse, double productionLevel,
							   double solarIrradiance, double greyFilterRate,
							   double temperatureModifier) {

		if (currentPhase.getPhaseType() == PhaseType.FINISHED) {
			return false;
		}

		double elapsed = pulse.getElapsed();
		
		// Future: currentWorkRequired should be modified by the crop category. 
		// Some category of crop doesn't need much care while some need more attention
		currentWorkRequired += elapsed * growingArea / WORK_FACTOR;

		accumulatedTime += elapsed;

		double newCheckPeriod = CHECK_CROP_PERIOD * elapsed;
		
		if (accumulatedTime >= newCheckPeriod) {

			accumulatedTime -= newCheckPeriod;

			double time = accumulatedTime * productionLevel;

			growingTimeCompleted += time;
			
			double growingTime = cropSpec.getGrowingSols() * 1000D;
			percentageGrowth = (growingTimeCompleted * 100D) / growingTime;
			
			// Right before the harvesting phase
			if (currentPhase.getPhaseType() != PhaseType.HARVESTING
					&& percentageGrowth > currentPhase.getCumulativePercentGrowth()) {
				// Advance onto the next phase
				advancePhase();
			}

			// max possible harvest within this period of time
			double maxPeriodHarvest = maxHarvest * (time / growingTime);
			// Compute each harvestModifiers and sum them up below
			// Note: computeHarvest takes up 40% of all cpu utilization
			double harvestModifier = computeHarvest(maxPeriodHarvest, pulse, time,
													solarIrradiance,
													greyFilterRate,
													temperatureModifier);
			// Add to the daily harvest.
			dailyHarvest += maxPeriodHarvest * harvestModifier;
			// Add to the cumulative harvest.
			remainingHarvest += maxPeriodHarvest * harvestModifier;

			if ((dailyHarvest < 0) || (percentageGrowth > 110D)) {
				updatePhase(PhaseType.FINISHED);
			}

			if (currentPhase.getPhaseType() == PhaseType.FINISHED) {
				dailyHarvest = 0;
				totalHarvest = 0;
			}
		}

		// Resets thing at the end of a sol.
		if (resetEndOfSol(pulse)) {
			// Add tasks
		}
		
		int msol = pulse.getMarsTime().getMillisolInt();
		if (pulse.isNewHalfMillisol() || (pulse.isNewIntMillisol() && msol % CHECK_HEALTH_FREQUENCY == 0)) {
			// Checks on crop health
			trackHealth();
		}
		
		return true;
	}

	/**
	 * Resets things at the end of a sol.
	 *
	 * @param pulse
	 * @return
	 */
	private boolean resetEndOfSol(ClockPulse pulse) {
		if (pulse.isNewSol()) {

			// Note: is it better off doing the actualHarvest computation once a day or
			// every time
			// Reset the daily work counter currentPhaseWorkCompleted back to zero
			cumulativeDailyPAR = 0;
			
			if (dailyHarvest < 0) {
				updatePhase(PhaseType.FINISHED);
				dailyHarvest = 0;
				return true;
			}
		}

		return false;
	}

	public void resetPAR() {
		cumulativeDailyPAR = 0;
	}
	
	/**
	 * Turns on lighting.
	 *
	 * @param kW
	 */
	private void turnOnLighting(double kW) {
		lightingPower = kW;
	}

	/**
	 * Turns off lighting.
	 */
	private void turnOffLighting() {
		lightingPower = 0;
	}

	/**
	 * Computes the effects of the available sunlight and artificial light.
	 *
	 * @param time
	 * @param solarIrradiance
	 * @return instantaneous PAR or uPAR
	 */
	private double computeLight(ClockPulse pulse, double time, double solarIrradiance) {
		double lightModifier = 0;

		// Note : The average PAR is estimated to be 20.8 mol/(m² day) (Gertner, 1999)
		// Calculate instantaneous PAR from solar irradiance
		double uPAR = wattToPhotonConversionRatio * solarIrradiance;
		// [umol /m^2 /s] = [u mol /m^2 /s /(Wm^-2)] * [Wm^-2]
		double intervalPAR = uPAR / 1_000_000D * time * MarsTime.SECONDS_PER_MILLISOL; // in mol / m^2 within this

		double dailyPARRequired = cropSpec.getDailyPAR();
		// period of time
		// [mol /m^2] = [umol /m^2 /s] / u * [millisols] * [s /millisols]
		// 1 u = 1 micro = 1/1_000_000
		// Note : daily-PAR has the unit of [mol /m^2 /day]
		// Gauge if there is enough sunlight

		// When enough PAR have been administered to the crop, HPS_LAMP will turn off.
		
		// Future: what if the time zone of a settlement causes sunlight to shine at near
		// the tail end of the currentMillisols time ?
		
		// Compared cumulativeDailyPAR / dailyPARRequired vs. current time /
		// 1000D
		
		// Reduce the frequent toggling on and off of lamp and to check on
		// the time of day to anticipate the need of sunlight.
			// Future: also compare also how much more sunlight will still be available
			if (uPAR > 40) { 
				// if sunlight is available
				turnOffLighting();
				
				cumulativeDailyPAR = cumulativeDailyPAR + intervalPAR;
				// Gets the effectivePAR
				effectivePAR = intervalPAR;
			}

			else { // if no sunlight, turn on artificial lighting
					// DLI is Daily Light Integral is the unit for for cumulative light -- the
					// accumulation of all the PAR received during a day.
				double dli = dailyPARRequired - cumulativeDailyPAR; // [in mol / m^2 / day]
				double deltaPAROutstanding = dli * (time / 1000D) * growingArea;
				// in mol needed at this delta time [mol] = [mol /m^2 /day] * [millisol] /
				// [millisols /day] * m^2
				double deltakW = deltaPAROutstanding / time / conversionFactor;
				// [kW] = [mol] / [u mol /m^2 /s /(Wm^-2)] / [millisols] / [s /millisols] = [W
				// /u] * u * k/10e-3 = [kW]; since 1 u = 10e-6
				
				// Future: Typically, 5 lamps per square meter for a level of ~1000 mol/ m^2 /s
				// Added PHYSIOLOGICAL_LIMIT sets a realistic limit for tuning how
				// much PAR a food crop can absorb per frame.
				
				// Note 1 : PHYSIOLOGICAL_LIMIT minimize too many lights turned on and off too
				// frequently
				
				// Note 2 : It serves to smooth out the instantaneous power demand over a period
				// of time
				
				// each HPS_LAMP lamp supplies 400W has only 40% visible radiation efficiency
				int numLamp = (int) (Math.ceil(deltakW / COMBINED_LAMP_FACTOR));
				// Future: should also allow the use of LED_KIT for lighting
				// For converting lumens to PAR/PPF, see
				// http://www.thctalk.com/cannabis-forum/showthread.php?55580-Converting-lumens-to-PAR-PPF
				// Note: do NOT include any losses below
				double supplykW = numLamp * COMBINED_LAMP_FACTOR;
				// Turn on the lamps
				turnOnLighting(supplykW);
				
				double deltaPARSupplied = supplykW * time * conversionFactor / growingArea; // in mol / m2
				// [ mol / m^2] = [kW] * [u mol /m^2 /s /(Wm^-2)] * [millisols] * [s /millisols]
				// / [m^2] = k u mol / W / m^2 * (10e-3 / u / k) = [mol / m^-2]
				cumulativeDailyPAR = cumulativeDailyPAR + deltaPARSupplied + intervalPAR;
				// [mol /m^2 /d]

				// Gets the effectivePAR
				effectivePAR = deltaPARSupplied + intervalPAR;
			}

		// check for the passing of each day
		int newSol = pulse.getMarsTime().getMissionSol();
		// the crop has memory of the past lighting condition
		lightModifier = cumulativeDailyPAR / (dailyPARRequired + .0001) * 1000D / ( time  + .0001);
		// Future: If too much light, the crop's health may suffer unless a person comes
		// to intervene
		if (isStartup && newSol == 1) {
			// if this crop is generated at the start of the sim,
			// lightModifier should start from 1, rather than 0
			lightModifier = 1;
		}

		adjustEnvironmentFactor(lightModifier, LIGHT_FACTOR);

		return uPAR;
	}

	/**
	 * Retrieves water or grey water from the Settlement and record the usage in the Farm.
	 * 
	 * @param amount Amount being retrieved
	 * @param id Resource id
	 */
	private void retrieveWater(double amount, int id) {
		if (amount > 0) {
			retrieve(amount, id, true);
			// Record the amount of water or grey water taken up by the crop
			farm.addCropUsage(name, amount, id);		
		}
	}
	
	/**
	 * Computes the effect of water and fertilizer.
	 *
	 * @param compositeFactor
	 * @param time
	 * @param greyFilterRate
	 */
	private void computeWaterFertilizer(double compositeFactor, double time, double greyFilterRate) {
		// Calculate water usage kg per sol
		double waterRequired = compositeFactor * averageWaterNeeded;
		if (waterRequired <= 0)
			return;
		// Determine the amount of grey water available.
		double gw = building.getSettlement().getAmountResourceStored(GREY_WATER_ID);
		double greyWaterAvailable = Math.min(gw * greyFilterRate * time, gw);
		double waterUsed = 0;
		double greyWaterUsed = 0;
		double waterModifier = 0;
		double fertilizerModifier = 0;

		// First water crops with grey water if it is available.
		if (greyWaterAvailable >= waterRequired) {
			greyWaterUsed = waterRequired;
			retrieveWater(greyWaterUsed, GREY_WATER_ID);
			waterModifier = 1D;
		}

		else {
			// If not enough grey water, use water
			greyWaterUsed = greyWaterAvailable;
			retrieveWater(greyWaterUsed, GREY_WATER_ID);

			waterRequired = waterRequired - greyWaterUsed;
			double waterAvailable = building.getSettlement().getAmountResourceStored(WATER_ID);

			if (waterAvailable >= waterRequired) {
				waterUsed = waterRequired;
				retrieveWater(waterUsed, WATER_ID);

				waterModifier = 1D;
			}
			else {
				// not enough water
				waterUsed = waterAvailable;
				retrieveWater(waterUsed, WATER_ID);

				// Incur penalty if water is NOT available
				// need to add .0001 in case waterRequired becomes zero
				waterModifier = (greyWaterUsed + waterUsed) / (waterRequired + .0001);
			}

			double fertilizerAvailable = building.getSettlement().getAmountResourceStored(FERTILIZER_ID);
			// The amount of fertilizer to be used depends on the water used
			double fertilizerRequired = FERTILIZER_NEEDED_WATERING * time * waterUsed;
			double fertilizerUsed = fertilizerRequired;

			if (fertilizerUsed > fertilizerAvailable) {
				// not enough fertilizer
				fertilizerUsed = fertilizerAvailable;
				// should incur penalty due to insufficient fertilizer
				fertilizerModifier = fertilizerUsed / (fertilizerRequired + 0.0001);
			} else {
				// there's enough fertilizer
				fertilizerModifier = 1D;
			}

			if (fertilizerUsed > 0) {
				retrieve(fertilizerUsed, FERTILIZER_ID, true);
			}

			adjustEnvironmentFactor(fertilizerModifier, FERTILIZER_FACTOR);

		}

		adjustEnvironmentFactor(waterModifier, WATER_FACTOR);

	}
	
	/**
	 * Computes the effects of the concentration of O2 and CO2.
	 *
	 * @param watt
	 * @param compositeFactor
	 */
	private void computeGases(double watt, double compositeFactor) {
		// Note: uPAR includes both sunlight and artificial light
		// Calculate O2 and CO2 usage kg per sol
		double o2Modifier = 0;
		double co2Modifier = 0;

		// A. During the night when light level is low
		if (watt < 40) {

			double o2Required = compositeFactor * averageOxygenNeeded;
			double o2Available = building.getSettlement().getAmountResourceStored(OXYGEN_ID);
			double o2Used = o2Required;

			o2Modifier = o2Available / o2Required;

			if (o2Used > o2Available)
				o2Used = o2Available;
			o2Cache = retrieveGas(o2Used, o2Cache, OXYGEN_ID);

			adjustEnvironmentFactor(o2Modifier, O2_FACTOR);

			// Determine the amount of co2 generated via gas exchange.
			double cO2Gen = o2Used * CO2_TO_O2_RATIO;
			co2Cache = storeGas(cO2Gen, co2Cache, CO2_ID);
		}

		else {
			// B. During the day

			// Determine harvest modifier by amount of carbon dioxide available.
			double cO2Req = compositeFactor * averageCarbonDioxideNeeded;
			double cO2Available = building.getSettlement().getAmountResourceStored(CO2_ID);
			double cO2Used = cO2Req;

			// Future: allow higher concentration of co2 to be pumped to increase the harvest
			// modifier to the harvest.

			co2Modifier = cO2Available / cO2Req;

			if (cO2Used > cO2Available)
				cO2Used = cO2Available;
			co2Cache = retrieveGas(cO2Used, co2Cache, CO2_ID);
			
			// Note: research how much high amount of CO2 may facilitate the crop growth and
			// reverse past bad health

			adjustEnvironmentFactor(co2Modifier, CO2_FACTOR);

			// 6CO2 + 6H2O + sunlight -> C6H12O6 + 6O2
			//
			// Determine the amount of oxygen generated during the day when photosynthesis
			// is taking place .
			double o2Gen = cO2Used * O2_TO_CO2_RATIO;
			o2Cache = storeGas(o2Gen, o2Cache, OXYGEN_ID);
		}
	}

	/**
	 * Adjusts the environmental factors.
	 *
	 * @param mod the modifier of interest
	 * @param type the
	 */
	private void adjustEnvironmentFactor(double mod, int type) {
		double f = environmentalFactor[type];
		f = 0.01 * mod + 0.99 * f;
		if (f > 1.25)
			f = 1.25;
		else if (f < 0.1 || Double.isNaN(f))
			f = 0.1;
		environmentalFactor[type] = f;
	}

	/**
	 * Computes each input and output constituent for a crop for the specified
	 * period of time and return the overall harvest modifier.
	 *
	 * @param solarIrradiance
	 * @param greyFilterRate
	 * @param temperatureModifier
	 * @param the maximum possible growth/harvest
	 * @param a   period of time in millisols
	 * @return the harvest modifier
	 */
	private double computeHarvest(double maxPeriodHarvest, ClockPulse pulse,
						double time, double solarIrradiance, double greyFilterRate,
						double temperatureModifier) {

		// Tune the growthFactor according to the stage of a crop
		double growthFactor = percentageGrowth/100.0;

		// STEP 1 : COMPUTE THE EFFECTS OF THE SUNLIGHT AND ARTIFICIAL LIGHT
		if (!cropSpec.needsLight()) {
			adjustEnvironmentFactor(1D, LIGHT_FACTOR);
		}
		else {
			computeLight(pulse, time, solarIrradiance);
		}

		// STEP 2 : COMPUTE THE EFFECTS OF THE TEMPERATURE
		adjustEnvironmentFactor(temperatureModifier, TEMPERATURE_FACTOR);

		// STEP 3 : COMPUTE THE NEED FACTOR AND COMPOSITE FACTOR (BASED ON LIGHT AND GROWTH FACTOR)
		double watt = effectivePAR / time / conversionFactor * growingArea * 1000;
		// Note: effectivePAR already includes both sunlight and artificial light

		// Note: needFactor aims to give a better modeling of the amount of water
		// and O2 and CO2 produced/consumed based on the growthFactor and
		// how much the amount of light available (which change the rate of photosynthesis)
		double needFactor = 2.5 * growthFactor;
		if (watt >= 40) {
			needFactor = growthFactor * (.0185 * watt + 1.76);
			// needFactor ranges from growthFactor * 2.5 to growthFactor * 11
		}

		double compositeFactor = TUNING_FACTOR * needFactor * time / 1000.0;

		// STEP 4 : COMPUTE THE EFFECTS OF THE WATER AND FERTIZILER
		computeWaterFertilizer(compositeFactor * WATER_MODIFIER, time, greyFilterRate);

		// STEP 5 : COMPUTE THE EFFECTS OF GASES (O2 and CO2 USAGE)
		// Note: computeGases takes up 25% of all cpu utilization
		computeGases(watt, compositeFactor * GAS_MODIFIER);
		// Note that mushrooms are fungi and consume O2 and release CO2

		// STEP 6 : TUNE HARVEST MODIFIER
		double harvestModifier = 1D;
		PhaseType phaseType = currentPhase.getPhaseType();
		// Note that light is the dominant environmental factor
		if (phaseType == PhaseType.GERMINATION) {
			harvestModifier = .8 * harvestModifier + .2 * harvestModifier * environmentalFactor[LIGHT_FACTOR];
		}
		else if ((phaseType != PhaseType.PLANTING) && (phaseType != PhaseType.INCUBATION)) {
			harvestModifier = .6 * harvestModifier + .4 * harvestModifier * environmentalFactor[LIGHT_FACTOR];
		}

		harvestModifier = .25 * harvestModifier + .15 * harvestModifier * environmentalFactor[FERTILIZER_FACTOR]
						+ .15 * harvestModifier * environmentalFactor[TEMPERATURE_FACTOR]
						+ .15 * harvestModifier * environmentalFactor[WATER_FACTOR]
						+ .15 * harvestModifier * environmentalFactor[O2_FACTOR]
						+ .15 * harvestModifier * environmentalFactor[CO2_FACTOR];

		// NOTE 1: Use a better theoretical model for crop growth,
		//         instead of an empirical model
		// NOTE 2: Tune the calculation uniquely to each crop
		// NOTE 3: Modify harvest modifier based on the pollination rate
		//         by the number of bees in the greenhouse
		// NOTE 4: Modify harvest modifier by amount of artificial light available
		//         to the whole greenhouse
		// NOTE 5: Research how the above 6 factors may affect crop growth for different
		//         crop categories
		// NOTE 6: Add air pressure modifier in future

		return harvestModifier;
	}

	public double getHealthCondition() {
		return healthCondition;
	}

	public double getPercentGrowth() {
		return percentageGrowth;
	}

	public int getIdentifier() {
		return identifier;
	}


	/**
	 * Retrieves the gas from a settlement.
	 *
	 * @param amount
	 * @param gasCache Any gas cached from the last call
	 * @param gasId resource id
	 * @return
	 */
	private double retrieveGas(double amount, double gasCache, int gasId) {
		if (amount > 0) {
			if (gasCache - amount < -gasThreshold) {
				retrieve(gasCache, gasId, true);
				gasCache = -amount;
			}
			else {
				gasCache -= amount;
			}
			farm.addCropUsage(name, amount, gasId);
		}
		return gasCache;
	}

	/**
	 * Retrieves the amount resource.
	 *
	 * @param amount
	 * @param resource
	 * @param value
	 * @return
	 */
	private boolean retrieve(double amount, int resource, boolean value) {
		return (building.getSettlement().retrieveAmountResource(resource, amount) == 0);
	}

	/**
	 * Stores the gas.
	 *
	 * @param amount
	 * @return
	 */
	private double storeGas(double amount, double gasCache, int gasId) {
		if (amount > 0) {
			if (gasCache + amount > gasThreshold) {
				store(gasCache, gasId);
				gasCache = amount;
			}
			else {
				gasCache -= amount;
			}
			farm.addCropUsage(name, -amount, gasId);
		}
		return gasCache;
	}

	/**
	 * Stores the amount resource.
	 *
	 * @param amount
	 * @param resource
	 * @return
	 */
	private double store(double amount, int resource) {
		return building.getSettlement().storeAmountResource(resource, amount);
	}

	/**
	 * Does the Crop need power ? Checks the current phase to see if that is not the first or last.
	 * 
	 * @return
	 */
	public boolean needsPower() {
		PhaseType phaseType = currentPhase.getPhaseType();
		return (phaseType != PhaseType.INCUBATION) && (phaseType != PhaseType.FINISHED);
	}

	/**
	 * Compares if the object is the same as this crop.
	 */
	@Override
	public boolean equals(Object obj) {
		if (this == obj) return true;
		if (obj == null) return false;
		if (this.getClass() != obj.getClass()) return false;
		Crop c = (Crop) obj;
		return this.identifier == c.getIdentifier();
	}

	@Override
	public int hashCode() {
		return identifier % 32;
	}

	/**
	 * Reloads instances after loading from a saved sim.
	 * 
	 * @param cropConfig
	 */
	public static void initializeInstances(CropConfig cropConfig) {

		averageWaterNeeded = cropConfig.getWaterConsumptionRate();
		averageOxygenNeeded = cropConfig.getOxygenConsumptionRate();
		averageCarbonDioxideNeeded = cropConfig.getCarbonDioxideConsumptionRate();
		wattToPhotonConversionRatio = cropConfig.getWattToPhotonConversionRatio();
		// Note: conversionFactor is 51.45578648029399
		conversionFactor = 1000D * wattToPhotonConversionRatio / MarsTime.SECONDS_PER_MILLISOL;
	}

	@Override
	public String toString() {
		return "Crop [name=" + name + " @ " + building + "]";
	}

	@Override
	public int compareTo(Crop o) {
		return cropSpec.compareTo(o.getCropSpec());
	}

	@Override
	public String getName() {
		return getCropName();
	}

	/**
	 * The context of a Crop is always th context of the parent Building.
	 */
	@Override
	public String getContext() {
		return building.getContext();
	}

	/**
	 * Prepares object for garbage collection.
	 */
	public void destroy() {
		cropSpec = null;
		currentPhase = null;
		farm = null;
		building = null;
	}
}
