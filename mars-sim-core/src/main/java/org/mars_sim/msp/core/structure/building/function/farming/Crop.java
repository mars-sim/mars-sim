/*
 * Mars Simulation Project
 * Crop.java
 * @date 2022-07-28
 * @author Scott Davis
 */
package org.mars_sim.msp.core.structure.building.function.farming;

import java.io.Serializable;
import java.util.Arrays;
import java.util.logging.Level;

import org.mars_sim.msp.core.logging.SimLogger;
import org.mars_sim.msp.core.person.Person;
import org.mars_sim.msp.core.person.ai.task.utils.Worker;
import org.mars_sim.msp.core.resource.ItemResourceUtil;
import org.mars_sim.msp.core.resource.ResourceUtil;
import org.mars_sim.msp.core.structure.building.Building;
import org.mars_sim.msp.core.time.ClockPulse;
import org.mars_sim.msp.core.time.MarsClock;
import org.mars_sim.msp.core.time.MasterClock;
import org.mars_sim.msp.core.tool.RandomUtil;

/**
 * The Crop class describes the behavior of a crop growing on a greenhouse.
 */
public class Crop implements Comparable<Crop>, Serializable {

	/** default serial id. */
	private static final long serialVersionUID = 1L;
	/** default logger. */
	private static SimLogger logger = SimLogger.getLogger(Crop.class.getName());
	
	private static final int WATER_ID = ResourceUtil.waterID;
	private static final int OXYGEN_ID = ResourceUtil.oxygenID;
	private static final int CO2_ID = ResourceUtil.co2ID;
	private static final int GREY_WATER_ID = ResourceUtil.greyWaterID;
	private static final int CROP_WASTE_ID = ResourceUtil.cropWasteID;
	private static final int FERTILIZER_ID = ResourceUtil.fertilizerID;
	private static final int MUSHROOM_BOX_ID = ItemResourceUtil.mushroomBoxID;

	private static final int LIGHT_FACTOR = 0;
	private static final int FERTILIZER_FACTOR = 1;
	private static final int TEMPERATURE_FACTOR = 2;
	
	private static final int WATER_FACTOR = 3;
	private static final int O2_FACTOR = 4;
	private static final int CO2_FACTOR = 5;
	/** How often to calculate the crop health */
	private static final int CHECK_HEALTH_FREQUENCY = 20;
	
	/** The mininum time offset [in millisols] for a crop that requires work. */
	private static final double CROP_TIME_OFFSET = 5;
	
	// Future: Move params into crops.xml and load from CropConfig
	/** How often are the crops checked in mSols */
	private static final double CHECK_CROP_PERIOD = 4D;

	private static final double TUNING_FACTOR = 3.5;
	
	private static final double GAS_MODIFIER = 1.5;
	
	private static final double WATER_MODIFIER = 1.1;
	
	/**
	 * The limiting factor that determines how fast and how much PAR can be absorbed
	 * in one frame.
	 */
	private static final double PHYSIOLOGICAL_LIMIT = 0.9; // 1 is max. if set to 1, a lot of lights will toggle on and
															// off undesirably.
	private static final double RATIO_LEAVES = .75;

	/** The average amount of new soil needed needed per square meters. */
	public static final double NEW_SOIL_NEEDED_PER_SQM = .2D;
	/**
	 * The average amount of fertilizers needed when watering (but not needed if
	 * supplied with grey water).
	 */
	public static final double FERTILIZER_NEEDED_WATERING = 0.00005D; // a very minute amount needed per unit time,
																		// called if grey water is not available
	/**
	 * The average amount of fertilizers needed per square meter when planting a new
	 * crop.
	 */
	public static final double FERTILIZER_NEEDED_IN_SOIL_PER_SQM = 1D;

	/**
	 * The ratio of oxygen to carbon during the day when photosynthesis is taking
	 * place and CO2 is absorbed and O2 is generated by the crop.
	 */
	private static final double O2_TO_CO2_RATIO = 44 / 32D;
	/**
	 * The rate of carbon dioxide to oxygen during night time when O2 is absorbed
	 * and CO2 is released by the crop.
	 * <p> Note: 6CO2 --> 6O2 since
	 * <p> 6nCO2 + 5nH2O ⇒ (C6H10O5)n + 6nO2
	 */
	private static final double CO2_TO_O2_RATIO = 32 / 44D; 

	/**  only 42% are EM within 400 to 700 nm. */
	// public static final double SOLAR_IRRADIANCE_TO_PAR_RATIO = .42; 

	/** For Mars, the unit is mol/m2/s/Wm-2 . */
	// public static final double WATT_TO_PHOTON_CONVERSION_RATIO = 4.609; 
	
	/** SurfaceFeatures.MEAN_SOLAR_IRRADIANCE * 4.56 * (not 88775.244)/1e6 = 237.2217 */
	// public static final double MEAN_DAILY_PAR = 237.2217D ; // in [umol/m2/day]
	
	/** The wattage of a 400W high pressure sodium (HPS) lamp. */
	private static final double KW_PER_HPS = .4;
	/** The lamp efficiency of the high pressure sodium (HPS) lamp. */
	private static final double VISIBLE_RADIATION_HPS = 0.4;
	/** The ballast loss of the high pressure sodium (HPS) lamp. */
	private static final double BALLAST_LOSS_HPS = 0.1;
	/** The non-visible radiation loss of the high pressure sodium (HPS) lamp. */
	private static final double NON_VISIBLE_RADIATION_HPS = .37;
	/** The conduction convection loss of the high pressure sodium (HPS) lamp. */
	private static final double CONDUCTION_CONVECTION_HPS = .13;
	/** The total loss of the high pressure sodium (HPS) lamp. */
	public static final double LOSS_FACTOR_HPS = NON_VISIBLE_RADIATION_HPS * .75 + CONDUCTION_CONVECTION_HPS / 2D;
	/** The minimal amount of resource to be retrieved. */
	private static final double MIN = 0.001;

	/** The string reference for mushroom */
	private static final String MUSHROOM = "mushroom";

	// Data members
	/** True if this crop is generated at the start of the sim . */
	private boolean isStartup;
	/** The crop identifier (unique only within a greenhouse). */
	private int identifier;
	/** The total amount of light received by this crop. */
	private double effectivePAR;
	/** The ratio between inedible and edible biomass */
	private double massRatio;
	/** The maximum possible harvest for this crop [in kg]. */
	private double maxHarvest;
	/** The remaining possible harvest for this crop [in kg]. */
	private double remainingHarvest;
	/** The completed work time in current phase [in millisols]. */
	private double currentPhaseWorkCompleted = 0;
	/** The daily harvest for crop [in kg/per sol]. */
	private double dailyHarvest;
	/** The total amount harvested [in kg]. */
	private double totalHarvest;
	/** The growing phase time completed thus far [in millisols]. */
	private double growingTimeCompleted;
	/** Percentage of growing completed */
	private double percentageGrowth;
	/** The area occupied by the crop in square meters. */
	private double growingArea;
	/** The cumulative value of the daily PAR so far. */
	private double cumulativeDailyPAR = 0;
	/** The required power for lighting [in kW]. */
	private double lightingPower = 0;
	/** The health condition factor of the crop. 1 = excellent. 0 = worst*/
	private double healthCondition = 1;
	/** The average water needed [in kg] */
	private double averageWaterNeeded;
	/** The average O2 needed [in kg] */
	private double averageOxygenNeeded;
	/** The average CO2 needed [in kg] */
	private double averageCarbonDioxideNeeded;
	/**
	 * The watt to photon conversion ratio on Mars as defined in crops.xml [in umol
	 * /m^2 /s /(Wm^-2)].
	 */
	private double wattToPhotonConversionRatio;
	/**
	 * The converted value of the watt to photon conversion ratio on Mars as defined
	 * in crops.xml [in umol /m^2 /millisols /(Wm^-2)].
	 */
	private double conversion_factor;
	/** The disease index of a crop. */
	private double diseaseIndex = 0;
	/** The cache for co2. */
	private double co2Cache = 0;
	/** The cache for o2. */	
	private double o2Cache = 0;
	/** The time accumulated [in millisols] for each crop update call. */
	private double accumulatedTime = RandomUtil.getRandomDouble(0, 1.0);

	private final double co2Threshold;
	
	private final double o2Threshold;

	/** The cache values of the past environment factors influencing the crop */
	private double[] environmentalFactor = new double[CO2_FACTOR + 1];

	private String name;

	private CropSpec cropSpec;

	/** Current phase of crop. */
	private Phase currentPhase;

	private Farming farm;
	private Building building;

	private static CropConfig cropConfig;

	/**
	 * Constructor.
	 *
	 * @param identifier      the identifier of this crop.
	 * @param cropType        the type of crop.
	 * @param growingArea     the area occupied by the crop [m^2]
	 * @param dailyMaxHarvest - Maximum possible food harvest for crop. (kg/sol)
	 * @param farm            - Farm crop being grown in.
	 * @param isStartup       - true if this crop is generated at the start of the
	 *                        sim)
	 * @param tissuePercent   the percentage of ticarbonDioxideIDure available based
	 *                        on the requested amount
	 */
	public Crop(int identifier, CropSpec cropType, double growingArea, double dailyMaxHarvest, Farming farm,
			boolean isStartup, double tissuePercent) {

		this.identifier = identifier;
		this.cropSpec = cropType;
		this.growingArea = growingArea;
		this.farm = farm;
		this.isStartup = isStartup;
		this.co2Threshold = growingArea/10.0;
		this.o2Threshold = growingArea/10.0;
		this.name = cropSpec.getName();

		// Set up env factor to be balanced
		Arrays.fill(environmentalFactor, 1D);

		building = farm.getBuilding();

		// Note : growingTime is in millisols
		double growingTime = cropType.getGrowingTime();
		// Note : growingDay in sols
		double growingDay = growingTime / 1000D;

		maxHarvest = dailyMaxHarvest * growingDay;
		// Set to zero initially
		remainingHarvest = 0;

		if (cropSpec.getSeedID() > 0) {
			massRatio = 1;
		}

		averageWaterNeeded = cropConfig.getWaterConsumptionRate();
		averageOxygenNeeded = cropConfig.getOxygenConsumptionRate();
		averageCarbonDioxideNeeded = cropConfig.getCarbonDioxideConsumptionRate();
		wattToPhotonConversionRatio = cropConfig.getWattToPhotonConversionRatio();

		conversion_factor = 1000D * wattToPhotonConversionRatio / MarsClock.SECONDS_PER_MILLISOL;

		PhaseType phaseType;
		if (!isStartup) {
			// if this is not a grown crop at the start of the sim, start from the beginning

			if (tissuePercent <= 0) {
				// assume a max 2-day incubation period if no 0% tissue culture is available
				currentPhaseWorkCompleted = 0;
				phaseType = PhaseType.INCUBATION;
				logger.log(building, Level.INFO, 0, " No " + name
						+ " tissue-culture left. Restocking.");
				// Need a petri dish
				if (building.getSettlement().hasItemResource(ItemResourceUtil.PETRI_DISH_ID)) {
					building.getSettlement().retrieveItemResource(ItemResourceUtil.PETRI_DISH_ID, 1);
				}
				else
					logger.log(building, Level.WARNING, 60_000, "No petri dish left for growing " + cropSpec.getName()
						+ " tissue-culture.");
			}

			else if (tissuePercent >= 100) {
				// assume zero day incubation period if 100% tissue culture is available
				currentPhaseWorkCompleted = 0;
				phaseType = PhaseType.PLANTING;
				logger.log(building, Level.INFO, 0, "Done growing " + name
						+ "'s tissue-culture. Transferring plantflets to the field.");

				// if it's growing mushroom
				if (name.toLowerCase().contains(MUSHROOM)) {
					setupMushroom();
				}
			}

			else {
				phaseType = PhaseType.INCUBATION;
				currentPhaseWorkCompleted = 1000D * cropSpec.getPhase(phaseType).getWorkRequired() * (100D - tissuePercent) / 100D;
				logger.log(building, Level.INFO, 0, "A work period of "
								+ Math.round(currentPhaseWorkCompleted / 1000D * 10D) / 10D
								+ " sols is needed to clone enough " + name + " tissues before planting.");
			}

		}

		else {
			// This is a grown crop at the start of the sim,
			// Set the percentage of growth randomly
			growingTimeCompleted = RandomUtil.getRandomDouble(growingTime * .95); // for testing only :
																					// growingTimeCompleted =
																					// growingTime - 3000 +
																					// RandomUtil.getRandomDouble(3000D);
																					// or = growingTime * .975;

			percentageGrowth = (growingTimeCompleted * 100D) / growingTime;

			// Fast track through the phases
			phaseType = PhaseType.INCUBATION;
			while (percentageGrowth > cropSpec.getNextPhasePercentage(phaseType)) {
				phaseType = cropSpec.getNextPhaseType(phaseType);
			}

			// Set the daily harvest
			dailyHarvest = dailyMaxHarvest;
			// Set the remaining harvest based on percentageGrowth
			remainingHarvest = (maxHarvest * percentageGrowth)/100D;
		}

		updatePhase(phaseType);
	}

	/**
	 * Updates the current phase to a new type.
	 * 
	 * @param phaseType
	 */
	private void updatePhase(PhaseType phaseType) {
		currentPhase = cropSpec.getPhase(phaseType);
	}

	/**
	 * Sets up mushroom.
	 */
	private void setupMushroom() {
		if (building.getSettlement().hasItemResource(MUSHROOM_BOX_ID)) {
			building.getSettlement().retrieveItemResource(MUSHROOM_BOX_ID, 1);
		}
		// Need a petri dish
		if (building.getSettlement().hasItemResource(ItemResourceUtil.PETRI_DISH_ID)) {
			building.getSettlement().retrieveItemResource(ItemResourceUtil.PETRI_DISH_ID, 1);
		}
		else
			logger.log(building, Level.WARNING, 60_000, "No petri dish left for isolating " + name
				+ " tissue-culture.");
		// Require some dead matter for fungi to decompose
		if (growingArea * .2 > MIN)
			retrieve(growingArea * .2, CROP_WASTE_ID, true);
	}

	public double getLightingPower() {
		return lightingPower;
	}

	public double getGrowingArea() {
		return growingArea;
	}

	/**
	 * Gets the crop spec that defines this Crop.
	 *
	 * @return crop type ID
	 */
	public CropSpec getCropSpec() {
		return cropSpec;
	}

	/**
	 * Gets the crop name.
	 *
	 * @return crop name
	 */
	public String getCropName() {
		return name;
	}

	/**
	 * Gets the phase type of the crop.
	 *
	 * @return phaseType
	 */
	public PhaseType getPhaseType() {
		return currentPhase.getPhaseType();
	}


	/**
	 * Gets the maximum possible food harvest for crop.
	 *
	 * @return food harvest (kg.)
	 */
	public double getMaxHarvest() {
		return maxHarvest;
	}

	/**
	 * Gets the amount of growing time completed.
	 *
	 * @return growing time (millisols)
	 */
	public double getGrowingTimeCompleted() {
		return growingTimeCompleted;
	}

	/**
	 * Checks if crop needs additional work on current sol.
	 *
	 * @return true if more work needed.
	 */
	public boolean requiresWork() {
		// Note that harvesting phase works differently
		if (currentPhase.getPhaseType() == PhaseType.HARVESTING)
			return true;

		return currentPhase.getWorkRequired() * 1000D - CROP_TIME_OFFSET > currentPhaseWorkCompleted;
	}


	/**
	 * Tracks the overall health condition of the crop.
	 * 
	 * @return condition as value from 0 (poor) to 1 (healthy)
	 */
	private double trackHealth() {
		// 0:bad, 1:good
		double health = 0D;

		switch(currentPhase.getPhaseType()) {
		case INCUBATION:
		case PLANTING:
			health = 1D;
			break;

		case GERMINATION:
			if (percentageGrowth <= 5D) {
				// avoid initial spurious data at the start of the sim
				health = 1D;
			}
			else {
				health = calculateHealth();
			}
			break;

		default:
			health = calculateHealth();
			break;
		}

		if (health > 1D)
			health = 1D;
		else if (health < 0D)
			health = 0D;

		if (percentageGrowth > 10D) {
			// Check on the health of a >10% growing crop
			if (health < .05) {
				logger.log(building, Level.WARNING, 0, "Crop " + name
						+ " died of very poor health (" + Math.round(health * 100D) / 100D + " %)");
				// Add Crop Waste
				double amt = (percentageGrowth * remainingHarvest * RandomUtil.getRandomDouble(.5))/100D;
				if (amt > 0) {
					store(amt, CROP_WASTE_ID, "Crop::trackHealth");
					logger.log(building, Level.WARNING, 0, amt + " kg Crop Waste generated from the dead " + name);
				}
				updatePhase(PhaseType.FINISHED);
			}
		}

		else { // fractionalGrowthCompleted < .1 && fractionalGrowthCompleted > 0D
				// Seedling (<10% grown crop) is less resilient and more prone to environmental
				// factors
			if (health < .2) {
				logger.log(building, Level.WARNING, 0, "The seedlings of " + name + " had poor health ("
						+ Math.round(health * 100D) / 100D + " %) and didn't survive.");
				// Add Crop Waste
				double amt = (percentageGrowth * remainingHarvest * RandomUtil.getRandomDouble(.5))/100D;
				if (amt > 0) {
					store(amt, CROP_WASTE_ID, "Crop::trackHealth");
					logger.log(building, Level.WARNING, 0, amt + " kg Crop Waste generated from the dead " + name);
				}
				updatePhase(PhaseType.FINISHED);
			}
		}

		// set healthCondition so that it can be accessed outside of this class
		healthCondition = health;

		return health;
	}

	/*
	 * Computes the health of a crop.
	 */
	private double calculateHealth() {
		double health = 0;
		double total = 0;
		int size = environmentalFactor.length;
		for (int i=0; i< size; i++) {
			if (cropSpec.getCropCategory() == CropCategory.FUNGI) {
				if (i == LIGHT_FACTOR)
					total = total + 1;
				else
					total = total + environmentalFactor[i];
			}

			else {
				total = total + environmentalFactor[i];
			}
		}

		// TODO: will need to model diseaseIndex
		health = (1 - diseaseIndex) * total / size;

		if (health > 1)
			health = 1;

		return health;
	}

	/**
	 * Adds work time to the crops current phase.
	 *
	 * @param workTime - Work time to be added (millisols)
	 * @return workTime remaining after working on crop (millisols)
	 * @throws Exception if error adding work.
	 */
	public double addWork(Worker worker, double workTime) {
		// Called by Farming's addWork()
		// Note: it's important to set remainingTime initially to zero. If not, addWork will be in endless while loop
		double remainingTime = 0;

		// Improve the health of the crop each time it's being worked on
		if (healthCondition < 1)
			healthCondition += .001 * workTime;
		if (healthCondition > 1)
			healthCondition = 1;

		double w = currentPhase.getWorkRequired() * 1000D;

		if (dailyHarvest < 0D) {
			dailyHarvest = 0;
			growingTimeCompleted = 0;
		}

		// Only do phases that need manual work
		PhaseType phaseType = currentPhase.getPhaseType();
		switch (phaseType) {
		case INCUBATION:
		case PLANTING:
			// at a particular growing phase (NOT including the harvesting phase)
			currentPhaseWorkCompleted += workTime;

			if (currentPhaseWorkCompleted >= w * 1.01) {
				remainingTime = currentPhaseWorkCompleted - w;
				currentPhaseWorkCompleted = 0D;
				advancePhase();
				logger.log(building, Level.FINE, 0, name + " had entered a new phase " + currentPhase.getPhaseType()
						+ "   Work Completed : " + Math.round(currentPhaseWorkCompleted * 10D) / 10D
						+ "   Work Required : " + Math.round(w * 10D) / 10D);
			}
			break;

		case MATURATION:
		case HARVESTING:
			// at the maturation or harvesting phase
			currentPhaseWorkCompleted += workTime;
			// Set the harvest multiplier
			int multiplier = 5;

			if (currentPhaseWorkCompleted >= w * 1.01) {
				// Modify parameter list to include crop name
				double lastHarvest = multiplier * dailyHarvest * workTime / w;

				if (remainingHarvest > 0) {
					collectProduce(lastHarvest);

					remainingHarvest -= lastHarvest;
					totalHarvest += lastHarvest;

					remainingTime = Math.min(workTime, currentPhaseWorkCompleted - w);

					// Don't end until there is nothing left ?
					if (remainingHarvest <= 0) {
						logger.log(building, worker, Level.INFO, 0, "Harvested a total of "
									+ Math.round(totalHarvest * 100.0) / 100.0 + " kg "
									+ name + ".", null);

						if (phaseType == PhaseType.MATURATION)
							logger.log(building, worker, Level.INFO, 0, "Closed out the initial harvest of "
									+ name + ".", null);

						else if (phaseType == PhaseType.HARVESTING)
							logger.log(building, worker, Level.INFO, 0, "Closed out the final harvest of "
									+ name + ".", null);

						// Reset the totalHarvest back to zero.
						totalHarvest = 0;
						// Sets the phase to FINISHED
						updatePhase(PhaseType.FINISHED);

						//  Check to see if a botany lab is available
						if (worker instanceof Person && !farm.checkBotanyLab())
							logger.log(building, worker, Level.INFO, 0,
									"Can't find an available lab bench to work on the tissue culture for "
											+ name + ".", null);
					}
				}
			}
			else {
				if (dailyHarvest > 0.00001) {
					// Continue the harvesting process
					double modifiedHarvest = multiplier * dailyHarvest * workTime / w;
					// Store the crop harvest
					if (modifiedHarvest > 0 && remainingHarvest > 0) {
						collectProduce(modifiedHarvest);
						remainingHarvest -= modifiedHarvest;
						totalHarvest += modifiedHarvest;
					}
					remainingTime = 0D;
				}
			}
			break;

		case FINISHED:
			// Shouldn't be here
			break;

		default:
			// at a particular growing phase (NOT including the harvesting phase)
			currentPhaseWorkCompleted += workTime;

			if (currentPhaseWorkCompleted >= w * 1.01) {
				remainingTime = Math.min(workTime, currentPhaseWorkCompleted - w);
				currentPhaseWorkCompleted = 0D;
			}
			break;
		}

		// Safety check
		if ((currentPhase.getPhaseType() == PhaseType.HARVESTING) && percentageGrowth > 115D)  {
			logger.log(building, Level.FINE, 0, name + "'s percentageGrowth is " + percentageGrowth
					   + "%  Setting the phase to FINISHED.");
			updatePhase(PhaseType.FINISHED);
		}

		return remainingTime;
	}

	/**
	 * Advances the crop to the next phase of growth.
	 */
	private void advancePhase() {
		currentPhase = cropSpec.getNextPhase(currentPhase);
		logger.fine(building, name + " is now in " + currentPhase.getPhaseType());
	}
	
	
	/**
	 * Collects the produce during harvest.
	 * 
	 * @param harvestMass
	 */
	private void collectProduce(double harvestMass) {
		boolean isSeedPlant = cropSpec.isSeedPlant();
		int seedID = cropSpec.getSeedID();
		int cropID = cropSpec.getCropID();
		String source = "Crop::collectProduce";

		if (isSeedPlant) {
			// Extract Sesame Seed.
			// Note the purpose for this plant is primarily the seeds
			store(harvestMass, seedID, source);
		}
		else if ((seedID > 0) && harvestMass * massRatio > 0) {
			// White Mustard has leaves as food. Also extract Mustard Seed
			store(harvestMass * massRatio, seedID, source);
			store(harvestMass, cropID, source);
		}
		else {
			store(harvestMass, cropID, source);
		}

		// Calculate the amount of leaves and crop wastes that are generated
		double inedible = harvestMass / cropSpec.getEdibleBiomass() * cropSpec.getInedibleBiomass();
		double cropWaste = inedible * RATIO_LEAVES;
		if (cropWaste > 0) {
			store(cropWaste, CROP_WASTE_ID, source);
		}

		if (cropSpec.getCropCategory() == CropCategory.LEAVES) {
			double leaves = inedible - cropWaste;
			if (leaves > 0) {
				store(leaves, ResourceUtil.leavesID, source);
			}
		}
	}

	/**
	 * Time passing for crop.
	 * 
	 * @param pulse
	 * @param productionLevel
	 * @param solarIrradiance
	 * @param greyFilterRate
	 * @param temperatureModifier
	 *
	 * @return
	 */
	public boolean timePassing(ClockPulse pulse, double productionLevel,
							   double solarIrradiance, double greyFilterRate,
							   double temperatureModifier) {
			
		PhaseType phaseType = currentPhase.getPhaseType();
		if (phaseType == PhaseType.FINISHED) {
			return false;
		}

		double elapsed = pulse.getElapsed();
		accumulatedTime += elapsed;

		if (accumulatedTime >= CHECK_CROP_PERIOD) {

			accumulatedTime = accumulatedTime - CHECK_CROP_PERIOD;

			double time = accumulatedTime * productionLevel;

			growingTimeCompleted += time;
			percentageGrowth = (growingTimeCompleted * 100D) / cropSpec.getGrowingTime();

			// Right before the harvesting phase
			if (phaseType != PhaseType.HARVESTING && percentageGrowth > cropSpec.getNextPhasePercentage(phaseType)) {
				// Advance onto the next phase
				advancePhase();
			}

			// max possible harvest within this period of time
			double maxPeriodHarvest = maxHarvest * (time / cropSpec.getGrowingTime());
			// Compute each harvestModifiers and sum them up below
			// Note: computeHarvest takes up 40% of all cpu utilization
			double harvestModifier = computeHarvest(maxPeriodHarvest, pulse, time,
													solarIrradiance,
													greyFilterRate,
													temperatureModifier);
			// Add to the daily harvest.
			dailyHarvest += maxPeriodHarvest * harvestModifier;
			// Add to the cumulative harvest.
			remainingHarvest += maxPeriodHarvest * harvestModifier;

			if ((dailyHarvest < 0) || (percentageGrowth > 110D)) {
				updatePhase(PhaseType.FINISHED);
			}

			if (currentPhase.getPhaseType() == PhaseType.FINISHED) {
				dailyHarvest = 0;
				totalHarvest = 0;
			}
		}

		// Resets thing at the end of a sol.
		if (resetEndOfSol(pulse)) {
			int msol = pulse.getMarsTime().getMillisolInt();
			if (msol % CHECK_HEALTH_FREQUENCY == 0) {
				// Checks on crop health
				trackHealth();
			}
		}
		
		return true;
	}

	/**
	 * Resets things at the end of a sol.
	 *
	 * @param pulse
	 * @return
	 */
	public boolean resetEndOfSol(ClockPulse pulse) {
		if (pulse.isNewSol()) {
		
			// Resets the daily harvest back to zero
			dailyHarvest = 0;

			if (dailyHarvest < 0) {
				updatePhase(PhaseType.FINISHED);
				dailyHarvest = 0;
				return true;
			}
			// Note: is it better off doing the actualHarvest computation once a day or
			// every time
			// Reset the daily work counter currentPhaseWorkCompleted back to zero
			// currentPhaseWorkCompleted = 0D;
			cumulativeDailyPAR = 0;
		}

		return false;
	}

	/**
	 * Turns on lighting.
	 *
	 * @param kW
	 */
	private void turnOnLighting(double kW) {
		lightingPower = kW;
	}

	/**
	 * Turns off lighting.
	 */
	private void turnOffLighting() {
		lightingPower = 0;
	}

	/**
	 * Computes the effects of the available sunlight and artificial light.
	 *
	 * @param time
	 * @param solarIrradiance
	 * @return instantaneous PAR or uPAR
	 */
	private double computeLight(ClockPulse pulse, double time, double solarIrradiance) {
		double lightModifier = 0;

		int msols = pulse.getMarsTime().getMillisolInt();
		// Note : The average PAR is estimated to be 20.8 mol/(m² day) (Gertner, 1999)
		// Calculate instantaneous PAR from solar irradiance
		double uPAR = wattToPhotonConversionRatio * solarIrradiance;
		// [umol /m^2 /s] = [u mol /m^2 /s /(Wm^-2)] * [Wm^-2]
		double PAR_interval = uPAR / 1_000_000D * time * MarsClock.SECONDS_PER_MILLISOL; // in mol / m^2 within this

		double dailyPARRequired = cropSpec.getDailyPAR();
		// period of time
		// [mol /m^2] = [umol /m^2 /s] / u * [millisols] * [s /millisols]
		// 1 u = 1 micro = 1/1_000_000
		// Note : daily-PAR has the unit of [mol /m^2 /day]
		// Gauge if there is enough sunlight
		double progress = cumulativeDailyPAR / dailyPARRequired; // [max is 1]

		double clock = msols / 1000D; // [max is 1]

		// When enough PAR have been administered to the crop, the HPS_LAMP will turn
		// off.
		// TODO: what if the time zone of a settlement causes sunlight to shine at near
		// the tail end of the currentMillisols time ?
		// Compared cumulativeDailyPAR / dailyPARRequired vs. current time /
		// 1000D
		// Reduce the frequent toggling on and off of lamp and to check on
		// the time of day to anticipate the need of sunlight.
		if (0.5 * progress < clock && msols <= 333 || 0.7 * progress < clock && msols > 333 && msols <= 666
				|| progress < clock && msols > 666) {
			// TODO: also compare also how much more sunlight will still be available
			if (uPAR > 40) { // if sunlight is available
				turnOffLighting();
				cumulativeDailyPAR = cumulativeDailyPAR + PAR_interval;
				// Gets the effectivePAR
				effectivePAR = PAR_interval;
			}

			else { // if no sunlight, turn on artificial lighting
					// double conversion_factor = 1000D * wattToPhotonConversionRatio /
					// MarsClock.SECONDS_IN_MILLISOL ;
					// DLI is Daily Light Integral is the unit for for cumulative light -- the
					// accumulation of all the PAR received during a day.
				double DLI = dailyPARRequired - cumulativeDailyPAR; // [in mol / m^2 / day]
				double delta_PAR_outstanding = DLI * (time / 1000D) * growingArea;
				// in mol needed at this delta time [mol] = [mol /m^2 /day] * [millisol] /
				// [millisols /day] * m^2
				double delta_kW = delta_PAR_outstanding / time / conversion_factor;
				// [kW] = [mol] / [u mol /m^2 /s /(Wm^-2)] / [millisols] / [s /millisols] = [W
				// /u] * u * k/10e-3 = [kW]; since 1 u = 10e-6
				// TODO: Typically, 5 lamps per square meter for a level of ~1000 mol/ m^2 /s
				// Added PHYSIOLOGICAL_LIMIT sets a realistic limit for tuning how
				// much PAR a food crop can absorb per frame.
				// Note 1 : PHYSIOLOGICAL_LIMIT minimize too many lights turned on and off too
				// frequently
				// Note 2 : It serves to smooth out the instantaneous power demand over a period
				// of time
				// each HPS_LAMP lamp supplies 400W has only 40% visible radiation efficiency
				int numLamp = (int) (Math.ceil(
						delta_kW / KW_PER_HPS / VISIBLE_RADIATION_HPS / (1 - BALLAST_LOSS_HPS) * PHYSIOLOGICAL_LIMIT));
				// TODO: should also allow the use of LED_KIT for lighting
				// For converting lumens to PAR/PPF, see
				// http://www.thctalk.com/cannabis-forum/showthread.php?55580-Converting-lumens-to-PAR-PPF
				// Note: do NOT include any losses below
				double supplykW = numLamp * KW_PER_HPS * VISIBLE_RADIATION_HPS * (1 - BALLAST_LOSS_HPS)
						/ PHYSIOLOGICAL_LIMIT;
				turnOnLighting(supplykW);
				double delta_PAR_supplied = supplykW * time * conversion_factor / growingArea; // in mol / m2
				// [ mol / m^2] = [kW] * [u mol /m^2 /s /(Wm^-2)] * [millisols] * [s /millisols]
				// / [m^2] = k u mol / W / m^2 * (10e-3 / u / k) = [mol / m^-2]
				cumulativeDailyPAR = cumulativeDailyPAR + delta_PAR_supplied + PAR_interval;
				// [mol /m^2 /d]

				// Gets the effectivePAR
				effectivePAR = delta_PAR_supplied + PAR_interval;
			}
		}

		else {
			turnOffLighting();
		}

		// check for the passing of each day
		int newSol = pulse.getMarsTime().getMissionSol();
		// the crop has memory of the past lighting condition
		lightModifier = cumulativeDailyPAR / (dailyPARRequired + .0001) * 1000D / ( msols  + .0001);
		// TODO: If too much light, the crop's health may suffer unless a person comes
		// to intervene
		if (isStartup && newSol == 1) {
			// if this crop is generated at the start of the sim,
			// lightModifier should start from 1, rather than 0
			lightModifier = 1;
		}

		adjustEnvironmentFactor(lightModifier, LIGHT_FACTOR);

		return uPAR;
	}


	/***
	 * Computes the effect of water and fertilizer.
	 *
	 * @param compositeFactor
	 * @param time
	 * @param greyFilterRate
	 */
	private void computeWaterFertilizer(double compositeFactor, double time, double greyFilterRate) {
		// Calculate water usage kg per sol
		double waterRequired = compositeFactor * averageWaterNeeded;
		if (waterRequired <= 0)
			return;
		// Determine the amount of grey water available.
		double gw = building.getSettlement().getAmountResourceStored(GREY_WATER_ID);
		double greyWaterAvailable = Math.min(gw * greyFilterRate * time, gw);
		double waterUsed = 0;
		double greyWaterUsed = 0;
		double waterModifier = 0;
		double fertilizerModifier = 0;

		// First water crops with grey water if it is available.
		if (greyWaterAvailable >= waterRequired) {
			greyWaterUsed = waterRequired;

			if (greyWaterUsed > 0) {
				retrieve(greyWaterUsed, GREY_WATER_ID, true);
				//  Records the daily water usage in the farm
				farm.addDailyWaterUsage(greyWaterUsed);
				// Record the amount of grey water taken up by the crop
				addGreyWaterUsed(greyWaterUsed);		
			}
			waterModifier = 1D;
		}

		else {
			// If not enough grey water, use water
			greyWaterUsed = greyWaterAvailable;
			if (greyWaterUsed > 0) {
				retrieve(greyWaterUsed, GREY_WATER_ID, true);
				//  Records the daily water usage in the farm
				farm.addDailyWaterUsage(greyWaterUsed);
				// Record the amount of grey water taken up by the crop
				addGreyWaterUsed(greyWaterUsed);	
			}

			waterRequired = waterRequired - greyWaterUsed;
			double waterAvailable = building.getSettlement().getAmountResourceStored(WATER_ID);

			if (waterAvailable >= waterRequired) {
				waterUsed = waterRequired;
				if (waterUsed > 0) {
					retrieve(waterUsed, WATER_ID, true);
					//  Records the daily water usage in the farm
					farm.addDailyWaterUsage(waterUsed);
					// Record the amount of water taken up by the crop
					addWaterUsed(waterUsed);
				}

				waterModifier = 1D;
			}
			else {
				// not enough water
				waterUsed = waterAvailable;
				if (waterUsed > 0) {
					retrieve(waterUsed, WATER_ID, true);
					//  Records the daily water usage in the farm
					farm.addDailyWaterUsage(waterUsed);
					// Record the amount of water taken up by the crop
					addWaterUsed(waterUsed);
				}
				// Incur penalty if water is NOT available
				// need to add .0001 in case waterRequired becomes zero
				waterModifier = (greyWaterUsed + waterUsed) / (waterRequired + .0001);
			}

			double fertilizerAvailable = building.getSettlement().getAmountResourceStored(FERTILIZER_ID);
			// The amount of fertilizer to be used depends on the ratio of the grey water used
			double fertilizerRequired = FERTILIZER_NEEDED_WATERING * time * greyWaterUsed / (greyWaterUsed + waterUsed + .0001);
			double fertilizerUsed = fertilizerRequired;

			if (fertilizerUsed > fertilizerAvailable) {
				// not enough fertilizer
				fertilizerUsed = fertilizerAvailable;
				// should incur penalty due to insufficient fertilizer
				fertilizerModifier = fertilizerUsed / (fertilizerRequired + 0.0001);
			} else {
				// there's enough fertilizer
				fertilizerModifier = 1D;
			}

			if (fertilizerUsed > 0) {
				retrieve(fertilizerUsed, FERTILIZER_ID, true);
			}

			adjustEnvironmentFactor(fertilizerModifier, FERTILIZER_FACTOR);

		}

		// Amount of water reclaimed through a Moisture Harvesting System inside the
		// Greenhouse

		// NOTE: Modify harvest modifier according to the moisture level

		// double waterReclaimed = totalWaterUsed * growingArea * time / 1000D *
		// MOISTURE_RECLAMATION_FRACTION;
		// if (waterReclaimed > 0)
		// Storage.storeAnResource(waterReclaimed, waterID, inv, sourceName +
		// "::computeWaterFertilizer");

		// Assume an universal rate of water vapor evaporation rate of 5%
		// farm.addMoisture(totalWaterUsed*.05);

		// Record the amount of water taken up by the crop
//		if (waterUsed > MIN)
//			addWaterUsed(waterUsed);

		adjustEnvironmentFactor(waterModifier, WATER_FACTOR);

	}

	private void addWaterUsed(double amount) {
		farm.addCropUsage(name, amount, 0);
	}

	private void addGreyWaterUsed(double amount) {
		farm.addCropUsage(name, amount, 3);
	}
	
	private void addO2Used(double amount) {
		farm.addCropUsage(name, amount, 1);
	}
	
	private void addCO2Used(double amount) {
		farm.addCropUsage(name, amount, 2);
	}
	
	/**
	 * Computes the effects of the concentration of O2 and CO2.
	 *
	 * @param watt
	 * @param compositeFactor
	 */
	private void computeGases(double watt, double compositeFactor) {
		// Note: uPAR includes both sunlight and artificial light
		// Calculate O2 and CO2 usage kg per sol
		double o2Modifier = 0;
		double co2Modifier = 0;

		// A. During the night when light level is low
		if (watt < 40) {

			double o2Required = compositeFactor * averageOxygenNeeded;
			double o2Available = building.getSettlement().getAmountResourceStored(OXYGEN_ID);
			double o2Used = o2Required;

			o2Modifier = o2Available / o2Required;

			if (o2Used > o2Available)
				o2Used = o2Available;
			if (o2Used > 0) {
				retrieveO2(o2Used);
				addO2Used(o2Used);
			}

			adjustEnvironmentFactor(o2Modifier, O2_FACTOR);

			// Determine the amount of co2 generated via gas exchange.
			double cO2Gen = o2Used * CO2_TO_O2_RATIO;
			if (cO2Gen > 0) {
				storeCO2(cO2Gen);
				addCO2Used(-cO2Gen);
			}
		}

		else {
			// B. During the day

			// Determine harvest modifier by amount of carbon dioxide available.
			double cO2Req = compositeFactor * averageCarbonDioxideNeeded;
			double cO2Available = building.getSettlement().getAmountResourceStored(CO2_ID);
			double cO2Used = cO2Req;

			// TODO: allow higher concentration of co2 to be pumped to increase the harvest
			// modifier to the harvest.

			co2Modifier = cO2Available / cO2Req;

			if (cO2Used > cO2Available)
				cO2Used = cO2Available;
			if (cO2Used > 0) {
				retrieveCO2(cO2Used);
				addCO2Used(cO2Used);
			}
			// Note: research how much high amount of CO2 may facilitate the crop growth and
			// reverse past bad health

			adjustEnvironmentFactor(co2Modifier, CO2_FACTOR);

			// 6CO2 + 6H2O + sunlight -> C6H12O6 + 6O2
			//
			// Determine the amount of oxygen generated during the day when photosynthesis
			// is taking place .
			double o2Gen = cO2Used * O2_TO_CO2_RATIO;
			if (o2Gen > 0) {
				storeO2(o2Gen);
				addO2Used(-o2Gen);
			}
		}
	}

	/**
	 * Adjusts the environmental factors.
	 *
	 * @param mod the modifier of interest
	 * @param type the
	 */
	private void adjustEnvironmentFactor(double mod, int type) {
		double f = environmentalFactor[type];
		f = 0.01 * mod + 0.99 * f;
		if (f > 1.25)
			f = 1.25;
		else if (f < 0.1 || Double.isNaN(f))
			f = 0.1;
		environmentalFactor[type] = f;
	}

	/**
	 * Computes each input and output constituent for a crop for the specified
	 * period of time and return the overall harvest modifier.
	 *
	 * @param solarIrradiance
	 * @param greyFilterRate
	 * @param temperatureModifier
	 * @param the maximum possible growth/harvest
	 * @param a   period of time in millisols
	 * @return the harvest modifier
	 */
	private double computeHarvest(double maxPeriodHarvest, ClockPulse pulse,
						double time, double solarIrradiance, double greyFilterRate,
						double temperatureModifier) {

		// Tune the growthFactor according to the stage of a crop
		double growthFactor = percentageGrowth/100.0;

		// STEP 1 : COMPUTE THE EFFECTS OF THE SUNLIGHT AND ARTIFICIAL LIGHT
		if (!cropSpec.needsLight()) {
			adjustEnvironmentFactor(1D, LIGHT_FACTOR);
		}
		else {
			computeLight(pulse, time, solarIrradiance);
		}

		// STEP 2 : COMPUTE THE EFFECTS OF THE TEMPERATURE
		adjustEnvironmentFactor(temperatureModifier, TEMPERATURE_FACTOR);

		// STEP 3 : COMPUTE THE NEED FACTOR AND COMPOSITE FACTOR (BASED ON LIGHT AND GROWTH FACTOR)
		double watt = effectivePAR / time / conversion_factor * growingArea * 1000;
		// Note: effectivePAR already includes both sunlight and artificial light

		// Note: needFactor aims to give a better modeling of the amount of water
		// and O2 and CO2 produced/consumed based on the growthFactor and
		// how much the amount of light available (which change the rate of photosynthesis)
		double needFactor = 2.5 * growthFactor;
		if (watt >= 40) {
			needFactor = growthFactor * (.0185 * watt + 1.76);
			// needFactor ranges from growthFactor * 2.5 to growthFactor * 11
		}

		double compositeFactor = TUNING_FACTOR * needFactor * time / 1000.0;

		// STEP 4 : COMPUTE THE EFFECTS OF THE WATER AND FERTIZILER
		computeWaterFertilizer(compositeFactor * WATER_MODIFIER, time, greyFilterRate);

		// STEP 5 : COMPUTE THE EFFECTS OF GASES (O2 and CO2 USAGE)
		// Note: computeGases takes up 25% of all cpu utilization
		computeGases(watt, compositeFactor * GAS_MODIFIER);
		// Note that mushrooms are fungi and consume O2 and release CO2

		// STEP 6 : TUNE HARVEST MODIFIER
		double harvestModifier = 1D;
		PhaseType phaseType = currentPhase.getPhaseType();
		// Note that light is the dominant environmental factor
		if (phaseType == PhaseType.GERMINATION) {
			harvestModifier = .8 * harvestModifier + .2 * harvestModifier * environmentalFactor[LIGHT_FACTOR];
		}
		else if ((phaseType != PhaseType.PLANTING) && (phaseType != PhaseType.INCUBATION)) {
			harvestModifier = .6 * harvestModifier + .4 * harvestModifier * environmentalFactor[LIGHT_FACTOR];
		}

		harvestModifier = .25 * harvestModifier + .15 * harvestModifier * environmentalFactor[FERTILIZER_FACTOR]
						+ .15 * harvestModifier * environmentalFactor[TEMPERATURE_FACTOR]
						+ .15 * harvestModifier * environmentalFactor[WATER_FACTOR]
						+ .15 * harvestModifier * environmentalFactor[O2_FACTOR]
						+ .15 * harvestModifier * environmentalFactor[CO2_FACTOR];

		// NOTE 1: Use a better theoretical model for crop growth,
		//         instead of an empirical model
		// NOTE 2: Tune the calculation uniquely to each crop
		// NOTE 3: Modify harvest modifier based on the pollination rate
		//         by the number of bees in the greenhouse
		// NOTE 4: Modify harvest modifier by amount of artificial light available
		//         to the whole greenhouse
		// NOTE 5: Research how the above 6 factors may affect crop growth for different
		//         crop categories
		// NOTE 6: Add air pressure modifier in future

		return harvestModifier;
	}

	public void resetPAR() {
		cumulativeDailyPAR = 0;
	}

	public double getHealthCondition() {
		return healthCondition;
	}

	public double getPercentGrowth() {
		return  Math.round(percentageGrowth * 10D)/10D;
	}

	public int getIdentifier() {
		return identifier;
	}

	/**
	 * Retrieves the carbon dioxide.
	 *
	 * @param amount
	 * @return
	 */
	private boolean retrieveCO2(double amount) {
		boolean result = false;
		if (co2Cache - amount < -co2Threshold) {
			result = retrieve(co2Cache, CO2_ID, true);
			co2Cache = -amount;
		}
		else {
			co2Cache -= amount;
		}
		return result;
	}

	/**
	 * Retrieves the oxygen.
	 *
	 * @param amount
	 * @return
	 */
	private boolean retrieveO2(double amount) {
		boolean result = false;
		if (o2Cache - amount < -o2Threshold) {
			result = retrieve(o2Cache, OXYGEN_ID, true);
			o2Cache = -amount;
		}
		else {
			o2Cache -= amount;
		}
		return result;
	}

	/**
	 * Retrieves the amount resource.
	 *
	 * @param amount
	 * @param resource
	 * @param value
	 * @return
	 */
	private boolean retrieve(double amount, int resource, boolean value) {
		if (building.getSettlement().retrieveAmountResource(resource, amount) == 0)
			return true;
		return false;
	}

	/**
	 * Stores the carbon dioxide.
	 *
	 * @param amount
	 * @return
	 */
	private boolean storeCO2(double amount) {
		boolean result = false;
		if (co2Cache + amount > co2Threshold) {
			result = store(co2Cache, CO2_ID, "Crop::storeCO2");
			co2Cache = amount;
		}
		else {
			co2Cache -= amount;
		}
		return result;
	}

	/**
	 * Stores the oxygen.
	 *
	 * @param amount
	 * @return
	 */
	private boolean storeO2(double amount) {
		boolean result = false;
		if (o2Cache + amount > o2Threshold) {
			result = store(o2Cache, OXYGEN_ID, "Crop::storeO2");
			o2Cache = amount;
		}
		else {
			o2Cache -= amount;
		}
		return result;
	}

	/**
	 * Stores the amount resource.
	 *
	 * @param amount
	 * @param resource
	 * @param source
	 * @return
	 */
	private boolean store(double amount, int resource, String source) {
		if (building.getSettlement().storeAmountResource(resource, amount) == 0)
			return true;
		return false;
	}


	/**
	 * Does the Crop need power ? Checks the current phase to see if that is not the first or last.
	 * 
	 * @return
	 */
	public boolean needsPower() {
		PhaseType phaseType = currentPhase.getPhaseType();
		return (phaseType != PhaseType.INCUBATION) && (phaseType != PhaseType.FINISHED);
	}

	/**
	 * Compares if the object is the same as this crop.
	 */
	@Override
	public boolean equals(Object obj) {
		if (this == obj) return true;
		if (obj == null) return false;
		if (this.getClass() != obj.getClass()) return false;
		Crop c = (Crop) obj;
		return this.identifier == c.getIdentifier();
	}

	@Override
	public int hashCode() {
		return identifier % 32;
	}

	/**
	 * Reloads instances after loading from a saved sim.
	 * 
	 * @param cropConfig2
	 *
	 * @param {@link MasterClock}
	 * @param {{@link MarsClock}
	 */
	public static void initializeInstances(CropConfig cropConfig2) {
		cropConfig = cropConfig2;
	}

	@Override
	public String toString() {
		return "Crop [name=" + name + " @ " + building + "]";
	}

	@Override
	public int compareTo(Crop o) {
		return cropSpec.compareTo(o.getCropSpec());
	}

}
