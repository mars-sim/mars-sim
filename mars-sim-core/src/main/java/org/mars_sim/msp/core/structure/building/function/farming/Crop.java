/**
 * Mars Simulation Project
 * Crop.java
 * @version 3.1.0 2017-09-17
 * @author Scott Davis
 */
package org.mars_sim.msp.core.structure.building.function.farming;

import java.io.Serializable;
import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.logging.Level;
import java.util.logging.Logger;

import org.mars_sim.msp.core.LogConsolidated;
import org.mars_sim.msp.core.Simulation;
import org.mars_sim.msp.core.SimulationConfig;
import org.mars_sim.msp.core.Unit;
import org.mars_sim.msp.core.UnitManager;
import org.mars_sim.msp.core.mars.SurfaceFeatures;
import org.mars_sim.msp.core.person.Person;
import org.mars_sim.msp.core.resource.ItemResourceUtil;
import org.mars_sim.msp.core.resource.ResourceUtil;
import org.mars_sim.msp.core.structure.Settlement;
import org.mars_sim.msp.core.structure.building.Building;
import org.mars_sim.msp.core.structure.building.function.Storage;
import org.mars_sim.msp.core.time.MarsClock;
import org.mars_sim.msp.core.time.MasterClock;
import org.mars_sim.msp.core.tool.Conversion;
import org.mars_sim.msp.core.tool.RandomUtil;

/**
 * The Crop class describes the behavior of a crop growing on a greenhouse.
 */
public class Crop implements Serializable {

	/** default serial id. */
	private static final long serialVersionUID = 1L;
	/** default logger. */
	private static Logger logger = Logger.getLogger(Crop.class.getName());
	
	private static String sourceName = logger.getName().substring(logger.getName().lastIndexOf(".") + 1,
			logger.getName().length());

	public static final double TUNING_FACTOR = 0.2;
	
	public static final int CHECK_HEALTH_FREQUENCY = 20;
	/**
	 * The limiting factor that determines how fast and how much PAR can be absorbed
	 * in one frame.
	 */
	public static final double PHYSIOLOGICAL_LIMIT = 0.9; // 1 is max. if set to 1, a lot of lights will toggle on and
															// off undesirably.
	public static final double RATIO_LEAVES = .75;
	
	/**
	 * The average percentage of tissues that can be extracted from a crop upon
	 * harvest.
	 */
	public static final double TISSUE_EXTRACTED_PERCENT = .1D;
	/** The average amount of carbon dioxide needed per harvest mass. */
	public static final double CARBON_DIOXIDE_NEEDED = 2D;
	/** The average amount of new soil needed needed per square meters. */
	public static final double NEW_SOIL_NEEDED_PER_SQM = .2D;
	/**
	 * The average amount of fertilizers needed when watering (but not needed if
	 * supplied with grey water).
	 */
	public static final double FERTILIZER_NEEDED_WATERING = 0.00005D; // a very minute amount needed per unit time,
																		// called if grey water is not available
	/**
	 * The average amount of fertilizers needed per square meter when planting a new
	 * crop.
	 */
	public static final double FERTILIZER_NEEDED_IN_SOIL_PER_SQM = 1D;
	/** The fraction of water moisture that can be reclaimed. */
	public static final double MOISTURE_RECLAMATION_FRACTION = .2D;
	/**
	 * The ratio of oxygen to carbon during the day when photosynthesis is taking
	 * place and CO2 is absorbed and O2 is generated by the crop.
	 */
	public static final double O2_TO_CO2_RATIO = 44 / 32D;
	/**
	 * The rate of carbon dioxide to oxygen during night time when O2 is absorbed
	 * and CO2 is released by the crop.
	 */
	public static final double CO2_TO_O2_RATIO = 32 / 44D; // 6 CO2 --> 6 O2
	// 6nCO2+5nH2O⇒(C6H10O5)n+6nO2

	// public static final double SOLAR_IRRADIANCE_TO_PAR_RATIO = .42; // only 42%
	// are EM within 400 to 700 nm
	// see
	// http://ccar.colorado.edu/asen5050/projects/projects_2001/benoit/solar_irradiance_on_mars.htm#_top
	// public static final double WATT_TO_PHOTON_CONVERSION_RATIO = 4.609; // in u
	// mol / m2 /s / W m-2 for Mars only

	/** The wattage of a 400W high pressure sodium (HPS) lamp. */
	public static final double kW_PER_HPS = .4;
	/** The lamp efficiency of the high pressure sodium (HPS) lamp. */
	public static final double VISIBLE_RADIATION_HPS = 0.4;
	/** The ballast loss of the high pressure sodium (HPS) lamp. */
	public static final double BALLAST_LOSS_HPS = 0.1;
	/** The non-visible radiation loss of the high pressure sodium (HPS) lamp. */
	public static final double NON_VISIBLE_RADIATION_HPS = .37;
	/** The conduction convection loss of the high pressure sodium (HPS) lamp. */
	public static final double CONDUCTION_CONVECTION_HPS = .13;
	/** The total loss of the high pressure sodium (HPS) lamp. */
	public static final double LOSS_FACTOR_HPS = NON_VISIBLE_RADIATION_HPS * .75 + CONDUCTION_CONVECTION_HPS / 2D;
	/** The average temperature tolerance of a crop [in C]. */
	private static final double T_TOLERANCE = 3D;
	/** The minimal amount of resource to be retrieved. */
	private static final double MIN = 0.00001;
	/** The string reference variable of the tissue culture */
	public static final String TISSUE_CULTURE = "tissue culture";
	/** The string reference for mustard */
	public static final String MUSTARD = "Mustard";
	/** The string reference for seed */
	public static final String SEED = "Seed";
	/** The string reference for sesame */
	public static final String SESAME = "Sesame";
	/** The string reference for mushroom */	
	public static final String MUSHROOM = "mushroom";
	
	// public static final double MEAN_DAILY_PAR = 237.2217D ; // in [mol/m2/day]
	// SurfaceFeatures.MEAN_SOLAR_IRRADIANCE * 4.56 * (not 88775.244)/1e6 = 237.2217

	// Data members
	/** The settlement's unique identifier */
	private int settlementID;
	/** The crop identifier (unique only within a greenhouse). */
	private int identifier;
	/** The cache for msols */
	private int msolCache;
	/** The current sol of month. */
	private int currentSol = 1;
	/** True if this crop is generated at the start of the sim . */
	private boolean isStartup;
	/**
	 * True if this crop has seeds. e.g. the mustard seed must be extracted from the
	 * white mustard plant
	 */
	private boolean hasSeed = false;
	/** True if this crop is a seeded plant. e.g. the sesame plant */
	private boolean isSeedPlant = false;
	/** The total amount of light received by this crop. */	
	private double effectivePAR;
	/** The ratio between inedible and edible biomass */
	private double massRatio;
	/** The maximum possible harvest for this crop [in kg]. */
	private double maxHarvest;
	/** The remaining possible harvest for this crop [in kg]. */
	private double remainingHarvest;
	/** The completed work time in current phase [in millisols]. */
	private double currentPhaseWorkCompleted = 0;
	/** The daily harvest for crop [in kg/per sol]. */
	private double dailyHarvest;
	/** The maximum possible daily harvest [in kg/per sol]. */
	private double dailyMaxHarvest;
	/** The total amount harvested [in kg]. */
	private double totalHarvest;
	/** The growing phase time completed thus far [in millisols]. */
	private double growingTimeCompleted;
	/** The area occupied by the crop in square meters. */
	private double growingArea;
	/** The total number of growing days [in millisols]. */
	private double growingTime;
	/** The fraction of the growing time completed. 0 to 1. */
	private double fractionalGrowingTimeCompleted;
	/** The initial temperature of the greenhouse. */
	private double t_initial;
	/** The daily PAR required. */
	private double dailyPARRequired;
	/** The cumulative value of the daily PAR so far. */
	private double cumulativeDailyPAR = 0;
	/** The required power for lighting [in kW]. */
	private double lightingPower = 0;
	/** The health condition factor of the crop. 1 = excellent. 0 = worst*/
	private double healthCondition = 1;
	/** The average water needed [in kg] */
	private double averageWaterNeeded;
	/** The average O2 needed [in kg] */
	private double averageOxygenNeeded;
	/** The average CO2 needed [in kg] */
	private double averageCarbonDioxideNeeded;
	/**
	 * The watt to photon conversion ratio on Mars as defined in crops.xml [in umol
	 * /m^2 /s /(Wm^-2)].
	 */
	private double wattToPhotonConversionRatio;
	/**
	 * The converted value of the watt to photon conversion ratio on Mars as defined
	 * in crops.xml [in umol /m^2 /millisols /(Wm^-2)].
	 */
	private double conversion_factor;
	/** The disease index of a crop */
	private double diseaseIndex = 0;

	private double cumulative_water_usage = 0;

	private double cumulative_o2 = 0;

	private double cumulative_co2 = 0;

	private double inedibleBiomass;
	
	private double edibleBiomass;
	
	/** The cache values of the pastor environment factors influencing the crop */
	private Double[] environmentalFactor = new Double[] { 
			1.0,   // light, 0
			1.0,   // fertilizer, 1
			1.0,   // temperature, 2
			1.0,   // water, 3
			1.0,   // o2, 4
			1.0 }; // co2, 5

	private String cropName;
	private String capitalizedCropName;
	private String farmName;

	/** Current phase of crop. */
	private PhaseType phaseType;
	private CropCategoryType cropCategoryType;

//	private Inventory inv;
	private Farming farm;
	private Building building;

	private int cropTypeID;
	private int cropID;
	private int seedID;

	private Map<Integer, Phase> phases = new HashMap<>();

	private static int waterID = ResourceUtil.waterID;
	private static int oxygenID = ResourceUtil.oxygenID;
	private static int carbonDioxideID = ResourceUtil.co2ID;
	private static int greywaterID = ResourceUtil.greyWaterID;
	private static int cropWasteID = ResourceUtil.cropWasteID;
	private static int fertilizerID = ResourceUtil.fertilizerID;
	
	private static int mushroomBoxID = ItemResourceUtil.mushroomBoxID;

	private static Simulation sim = Simulation.instance();
	private static MasterClock masterClock;
	private static MarsClock marsClock;
	private static SurfaceFeatures surface;
	private static CropConfig cropConfig;
	private static UnitManager unitManager = sim.getUnitManager();
	

	/**
	 * Constructor.
	 * 
	 * @param identifier      the identifier of this crop.
	 * @param cropType        the type of crop.
	 * @param growingArea     the area occupied by the crop [m^2]
	 * @param dailyMaxHarvest - Maximum possible food harvest for crop. (kg/sol)
	 * @param farm            - Farm crop being grown in.
	 * @param settlement      - the settlement the crop is located at.
	 * @param isStartup       - true if this crop is generated at the start of the
	 *                        sim)
	 * @param tissuePercent   the percentage of ticarbonDioxideIDure available based
	 *                        on the requested amount
	 */
	public Crop(int identifier, CropType cropType, double growingArea, double dailyMaxHarvest, Farming farm, Settlement settlement,
			boolean isStartup, double tissuePercent) {
		this.identifier = identifier;
		this.cropTypeID = cropType.getID();
		this.cropCategoryType = CropConfig.getCropCategoryType(cropTypeID);
		this.growingArea = growingArea;
		this.dailyMaxHarvest = dailyMaxHarvest;
		this.farm = farm;
		this.settlementID = settlement.getIdentifier();
		this.isStartup = isStartup;

		sourceName = sourceName.substring(sourceName.lastIndexOf(".") + 1, sourceName.length());

		inedibleBiomass = cropType.getInedibleBiomass();	
		edibleBiomass = cropType.getEdibleBiomass();
		
		building = farm.getBuilding();
		farmName = building.getNickName();
		phases = cropType.getPhases();

		cropConfig = SimulationConfig.instance().getCropConfiguration();
		surface = sim.getMars().getSurfaceFeatures();
		masterClock = sim.getMasterClock();
		marsClock = masterClock.getMarsClock();

		for (Phase p : phases.values()) {
			p.setHarvestFactor(1);
		}

		dailyPARRequired = cropType.getDailyPAR();
		cropName = cropType.getName();
		capitalizedCropName = Conversion.capitalize(cropName);
		// Note : growingTime is in millisols
		growingTime = cropType.getGrowingTime();
		// Note : growingDay in sols
		double growingDay = growingTime / 1000D;
		maxHarvest = dailyMaxHarvest * growingDay;
		// Set to zero initially
		remainingHarvest = 0;
		
		// Add special case for extracting seeds from White Mustard
		if (cropName.contains(MUSTARD)) //.equalsIgnoreCase("White " + MUSTARD))
			hasSeed = true;

		else if (cropName.equalsIgnoreCase(SESAME))
			isSeedPlant = true;

		if (hasSeed) {
			massRatio = 1;//inedibleBiomass / edibleBiomass;
			seedID = ResourceUtil.findIDbyAmountResourceName(MUSTARD + " " + SEED);
		}

		if (isSeedPlant) {
			massRatio = 1;//inedibleBiomass / edibleBiomass;
			seedID = ResourceUtil.findIDbyAmountResourceName(cropName + " " + SEED);
		}

		cropID = ResourceUtil.findIDbyAmountResourceName(cropName);

		averageWaterNeeded = cropConfig.getWaterConsumptionRate();
		averageOxygenNeeded = cropConfig.getOxygenConsumptionRate();
		averageCarbonDioxideNeeded = cropConfig.getCarbonDioxideConsumptionRate();
		wattToPhotonConversionRatio = cropConfig.getWattToPhotonConversionRatio();

		conversion_factor = 1000D * wattToPhotonConversionRatio / MarsClock.SECONDS_PER_MILLISOL;

		t_initial = building.getInitialTemperature();

		if (!isStartup) {
			// if this is not a grown crop at the start of the sim, start from the beginning

			if (tissuePercent <= 0) {
				// assume a max 2-day incubation period if no 0% tissue culture is available
				currentPhaseWorkCompleted = 0;
				phaseType = PhaseType.INCUBATION;
				LogConsolidated.log(Level.INFO, 0, sourceName,
						"[" + settlement + "] " + " No " + capitalizedCropName + " tissue culture left in " + farmName
								+ ". Will take time to incubate and restock in " + farmName + ".");
			}

			else if (tissuePercent >= 100) {
				// assume zero day incubation period if 100% tissue culture is available
				currentPhaseWorkCompleted = 0;
				phaseType = PhaseType.PLANTING;
				LogConsolidated.log(Level.INFO, 0, sourceName,
						"[" + settlement + "] Proceeding to transferring plantflets from " + capitalizedCropName
								+ "'s tissue culture into the field.");

				setupMushroom();
			}

			else {
				currentPhaseWorkCompleted = 1000D * phases.get(0).getWorkRequired() * (100D - tissuePercent) / 100D;
				phaseType = PhaseType.INCUBATION;
				LogConsolidated.log(Level.INFO, 0, sourceName,
						"[" + settlement + "] A work period of "
								+ Math.round(currentPhaseWorkCompleted / 1000D * 10D) / 10D
								+ " sols is needed to clone enough " + capitalizedCropName + " tissues before planting in " + farmName + ".");
			}

		}

		else {
			// This is a grown crop at the start of the sim,
			// Set the percentage of growth randomly
			growingTimeCompleted = RandomUtil.getRandomDouble(growingTime * .95); // for testing only :
																					// growingTimeCompleted =
																					// growingTime - 3000 +
																					// RandomUtil.getRandomDouble(3000D);
																					// or = growingTime * .975;

			fractionalGrowingTimeCompleted = growingTimeCompleted / growingTime;
		
//			 int current = getCurrentPhaseNum();
//			  
//			 if (fractionalGrowingTimeCompleted * 100D > getUpperPercent(current)) {
//				 phaseType = phases.get(current + 1).getPhaseType(); 
//			 }
			
			int size = phases.size();
			for (int i = 0; i < size - 1; i++) {
				if (fractionalGrowingTimeCompleted * 100D > getUpperPercent(i)) {
					phaseType = cropType.getPhases().get(i + 1).getPhaseType();
				}
			}

			// Set the daily harvest
			dailyHarvest = dailyMaxHarvest;
			// Set the remaining harvest based on the fractional growth
			remainingHarvest = maxHarvest * fractionalGrowingTimeCompleted;
		}

	}

	public void setupMushroom() {
		if (cropName.toLowerCase().contains(MUSHROOM)) {
			
			if (building.getInventory().hasItemResource(mushroomBoxID)) {
				building.getInventory().retrieveItemResources(mushroomBoxID, 1);
				building.getInventory().addItemDemand(mushroomBoxID, 2);
			}
			// Require some dead matter for fungi to decompose
			if (growingArea * .5 > MIN)
				retrieve(growingArea * .5, cropWasteID, true);
		}
	}

	public double getLightingPower() {
		return lightingPower;
	}

	public double getGrowingArea() {
		return growingArea;
	}

	/**
	 * Gets the crop type ID.
	 *
	 * @return crop type ID
	 */
	public int getCropTypeID() {
		return cropTypeID;
	}

	/**
	 * Gets the crop name
	 * 
	 * @return crop name
	 */
	public String getCropName() {
		return cropName;
	}
	
	/**
	 * Gets the phase type of the crop.
	 * 
	 * @return phaseType
	 */
	public PhaseType getPhaseType() {
		return phaseType;
	}


	/**
	 * Gets the maximum possible food harvest for crop.
	 * 
	 * @return food harvest (kg.)
	 */
	public double getMaxHarvest() {
		return maxHarvest;
	}

	/**
	 * Gets the amount of growing time completed.
	 * 
	 * @return growing time (millisols)
	 */
	public double getGrowingTimeCompleted() {
		return growingTimeCompleted;
	}

	/**
	 * Checks if crop needs additional work on current sol.
	 * 
	 * @return true if more work needed.
	 */
	public boolean requiresWork() {
		int n = getCurrentPhaseNum();
		if (n == -1)
			return false;
		else if (phaseType == PhaseType.HARVESTING)
			return true;
		else
			return phases.get(n).getWorkRequired() * 1000D >= currentPhaseWorkCompleted;
	}

	/**
	 * Tracks the overall health condition of the crop.
	 * 
	 * @return condition as value from 0 (poor) to 1 (healthy)
	 */
	public double trackHealth() {
		// 0:bad, 1:good
		double health = 0D;

		// fractionalGrowingTimeCompleted = growingTimeCompleted/growingTime;

		int current = getCurrentPhaseNum();
//		int length = phases.size();

		if (current < 2) {
			health = 1D;
		}

		else if (current == 2) {
			if (fractionalGrowingTimeCompleted <= .05) {
				// avoid initial spurious data at the start of the sim
				health = 1D;
			} else {
				health = calculateHealth();
			}
		}

//		else if (current > 3 && current < length - 1) {
//			// Including the harvesting phase
//			// Note : the crop will spend most of the time here
//			health = getHealth();
//		}

		else
			health = calculateHealth();

		if (health > 1D)
			health = 1D;
		else if (health < 0D)
			health = 0D;

		if (fractionalGrowingTimeCompleted > .1) {
			// Check on the health of a >10% growing crop
			if (health < .05) {
				String name = unitManager.getSettlementByID(settlementID).getName();
				logger.warning("Crop " + capitalizedCropName + " at " + name
						+ " died of very poor health (" + Math.round(health * 100D) / 100D + " %) in "
						+ name + " and didn't survive.");
				// Add Crop Waste
				double amt = fractionalGrowingTimeCompleted * remainingHarvest * RandomUtil.getRandomDouble(.5);
				if (amt > 0) {
					store(amt, cropWasteID, sourceName + "::trackHealth");
					logger.warning(amt + " kg Crop Waste generated from the dead " + capitalizedCropName);
				}
				phaseType = PhaseType.FINISHED;
			}
		}

		else { // fractionalGrowthCompleted < .1 && fractionalGrowthCompleted > 0D
				// Seedling (<10% grown crop) is less resilient and more prone to environmental
				// factors
			if (health < .2) {
				logger.warning("The seedlings of " + capitalizedCropName + " had poor health ("
						+ Math.round(health * 100D) / 100D + " %) in " + unitManager.getSettlementByID(settlementID).getName() + " and didn't survive.");
				// Add Crop Waste
				double amt = fractionalGrowingTimeCompleted * remainingHarvest * RandomUtil.getRandomDouble(.5);
				if (amt > 0) {
					store(amt, cropWasteID, sourceName + "::trackHealth");
					logger.warning(amt + " kg Crop Waste generated from the dead " + capitalizedCropName);
				}
				phaseType = PhaseType.FINISHED;
			}
		}

		// set healthCondition so that it can be accessed outside of this class
		healthCondition = health;
//		logger.info(capitalizedCropName + "'s health : " +
//				Math.round(health*100D)/100D);

		return health;
	}

	/*
	 * Computes the health of a crop
	 */
	public double calculateHealth() {
		double health = 0;
		double total = 0;
		int size = environmentalFactor.length;
		for (int i=0; i< size; i++) {		
//			System.out.println(this.getCropName() + "'s environmentalFactor [" + i + "] = " + environmentalFactor[i]);
			if (cropCategoryType == CropCategoryType.FUNGI) {
				if (i == 0)
					total = total + 1;
				else
					total = total + environmentalFactor[i];
			}
			
			else {
				total = total + environmentalFactor[i];
			}
		}
		
		// TODO: will need to model diseaseIndex
		health = (1 - diseaseIndex) * total / size;
		
		if (health > 1)
			health = 1;
		
		return health;
	}

	/**
	 * Adds work time to the crops current phase.
	 * 
	 * @param workTime - Work time to be added (millisols)
	 * @return workTime remaining after working on crop (millisols)
	 * @throws Exception if error adding work.
	 */
	public double addWork(Unit unit, double workTime) {
		// Called by Farming's addWork()
		double remainingTime = 0;
		// Note: it's important to set remainingTime initially to zero. If not, addWork will be in endless while loop
		int current = getCurrentPhaseNum();
		int length = phases.size();

		// Improve the health of the crop each time it's being worked on
		if (healthCondition < 1)
			healthCondition += .001 * workTime;
		if (healthCondition > 1)
			healthCondition = 1;
		
		double w = phases.get(current).getWorkRequired() * 1000D;

		if (dailyHarvest < 0D) {
			dailyHarvest = 0;
			growingTimeCompleted = 0;
		}

		if (current == 0 && current == 1) {
			// at a particular growing phase (NOT including the harvesting phase)
			currentPhaseWorkCompleted += workTime;

			if (currentPhaseWorkCompleted >= w * 1.01) {
				remainingTime = currentPhaseWorkCompleted - w;
				currentPhaseWorkCompleted = 0D;
				phaseType = phases.get(current + 1).getPhaseType();
				logger.fine(capitalizedCropName + " had entered a new phase " + phaseType
						+ "   Work Completed : " + Math.round(currentPhaseWorkCompleted * 10D) / 10D
						+ "   Work Required : " + Math.round(w * 10D) / 10D);
			}
		}

		else if (current < length - 2) {
			// at a particular growing phase (NOT including the harvesting phase)
			currentPhaseWorkCompleted += workTime;

			if (currentPhaseWorkCompleted >= w * 1.01) {
				remainingTime = currentPhaseWorkCompleted - w;
				currentPhaseWorkCompleted = 0D;
				// phaseType = phases.get(current + 1).getPhaseType();
			}
		}

		else if ((current == length - 2) && fractionalGrowingTimeCompleted > 1.15)  {
			logger.fine(cropName + "'s fractionalGrowingTimeCompleted is " + fractionalGrowingTimeCompleted + "  Setting the phase to FINISHED.");
			phaseType = PhaseType.FINISHED;	
		}
		
		// TODO: for leaves crop, one should be able to harvest leaves ANYTIME and NOT
		// to have to wait until harvest
		else if (current == length - 2 || current == length - 3) {
			// at the maturation or harvesting phase
			currentPhaseWorkCompleted += workTime;
			// Set the harvest multiplier
			int multiplier = 5;
			
			if (currentPhaseWorkCompleted >= w * 1.01) {
				// Harvest is over. Close out this phase
				double overWorkTime = currentPhaseWorkCompleted - w;
				// Modify parameter list to include crop name
				double lastHarvest = multiplier * dailyHarvest * (workTime - overWorkTime) / w;

				if (totalHarvest > 0) {
					
					if (isSeedPlant) {
						// Extract Sesame Seed. 
						// Note the purpose for this plant is primarily the seeds 
						store(lastHarvest, seedID, sourceName + "::addWork");
					}
					else if (hasSeed && lastHarvest * massRatio > 0) {
						// White Mustard has leaves as food. Also extract Mustard Seed
						store(lastHarvest * massRatio, seedID, sourceName + "::addWork");
						store(lastHarvest, cropID, sourceName + "::addWork");
					}
					else {
						store(lastHarvest, cropID, sourceName + "::addWork");
					}

					String name = unitManager.getSettlementByID(settlementID).getName();
					
					if (current == length - 3)
						logger.info(unit.getName() + " closed out the initial harvest of " + capitalizedCropName + " in "
							+ farmName + " at " + name);
					else if (current == length - 2)
						logger.info(unit.getName() + " closed out the final harvest of " + capitalizedCropName + " in "
								+ farmName + " at " + name);
					
					// Calculate the amount of leaves and crop wastes that are generated
					computeLeavesNCropWaste(lastHarvest);
					
					//  Check to see if a botany lab is available
					if (unit instanceof Person && !farm.checkBotanyLab(cropTypeID, (Person)unit))
						logger.info("Can't find an available lab bench to work on the tissue culture for " + cropName);

					remainingHarvest -= lastHarvest;
										
					totalHarvest += lastHarvest;
					
					remainingTime = overWorkTime;

					if (totalHarvest > 0)
						LogConsolidated.log(Level.INFO, 0, sourceName,
							"[" + name + "] " + unit.getName() + " harvested a total of "
									+ Math.round(totalHarvest * 100.0) / 100.0 + " kg "
									+ capitalizedCropName + " in " + farmName);
					
					// Reset the totalHarvest back to zero.
					totalHarvest = 0;
					// Sets the phase to FINISHED
					phaseType = PhaseType.FINISHED;
				}
				
			}

			else {

				if (dailyHarvest > 0.00001) {
					// Continue the harvesting process
					double modifiedHarvest = multiplier * dailyHarvest * workTime / w;
					// Store the crop harvest
					if (modifiedHarvest > 0 && remainingHarvest > 0) {
						if (isSeedPlant) {
							// Extract Sesame Seed. 
							// Note the purpose for this plant is primarily the seeds 
							store(modifiedHarvest, seedID, sourceName + "::addWork");
						}
						else if (hasSeed && modifiedHarvest * massRatio > 0) {
							// White Mustard has leaves as food. Also extract Mustard Seed
							store(modifiedHarvest * massRatio, seedID, sourceName + "::addWork");
							store(modifiedHarvest, cropID, sourceName + "::addWork");
						}
						else {
							store(modifiedHarvest, cropID, sourceName + "::addWork");
						}

						// Calculate the amount of leaves and crop wastes that are generated
						computeLeavesNCropWaste(modifiedHarvest);
						
						remainingHarvest -= modifiedHarvest;
						
						totalHarvest += modifiedHarvest;
					}

					remainingTime = 0D;

				}
			}
		}

		return remainingTime;
	}

	/**
	 * Computes the amount of leaves and crop waste generated
	 */
	public void computeLeavesNCropWaste(double harvestMass) {
//		double amountCropWaste = harvestMass * inedibleBiomass / (inedibleBiomass + edibleBiomass);
		double inedible = harvestMass / edibleBiomass * inedibleBiomass;
		double cropWaste = inedible * RATIO_LEAVES;
		if (cropWaste > 0) {
			store(cropWaste, cropWasteID, sourceName + "::generateCropWaste");
//			LogConsolidated.log(Level.INFO, 0, sourceName,
//					"[" + settlement + "] A total "  
//							+ Math.round(totalHarvest * 100.0) / 100.0 + " kg of crop waste was generated "
//							+ capitalizedCropName + " in " + farmName);
		}
		
		if (cropCategoryType != CropCategoryType.LEAVES) {
			double leaves = inedible - cropWaste;
			if (leaves > 0) {
				store(leaves, ResourceUtil.leavesID, sourceName + "::generateCropWaste");
	//			LogConsolidated.log(Level.INFO, 0, sourceName,
	//					"[" + settlement + "] A total "  
	//							+ Math.round(totalHarvest * 100.0) / 100.0 + " kg of crop waste was generated "
	//							+ capitalizedCropName + " in " + farmName);
			}
		}
	}
	
	public void updateUsage() {
//		if (cumulative_water_usage > 0) {
			// Records the water usage per crop in the farm
			farm.addCropUsage(cropName, cumulative_water_usage, currentSol, 0);
//			System.out.println("cumulative_water_usage : " + cumulative_water_usage);
			// Reset the water usage
			cumulative_water_usage = 0;
//		}

//		if (cumulative_o2 > 0) {
			// Records the CO2 consumption/generation in the farm
			farm.addCropUsage(cropName, cumulative_o2, currentSol, 1);
//			System.out.println("cumulative_o2 : " + cumulative_o2);
			// Reset the consumption/generation
			cumulative_o2 = 0;
//		}

//		if (cumulative_co2 > 0) {
			// Records the oxygen consumption/generation in the farm
			farm.addCropUsage(cropName, cumulative_co2, currentSol, 2);
//			System.out.println("cumulative_co2 : " + cumulative_co2);
			// Reset the consumption/generation
			cumulative_co2 = 0;
//		}
	}
	
	/**
	 * Time passing for crop.
	 * 
	 * @param time - amount of time passing (millisols)
	 */
	public void timePassing(double time) {

		int current = getCurrentPhaseNum();
		int length = phases.size();

		fractionalGrowingTimeCompleted = growingTimeCompleted / growingTime;

		growingTimeCompleted += time;

//		if (current > 1 && current < length - 1) {
			// From phase 2 to harvesting phase
			if (time > 0D) {
				// growingTimeCompleted += time;		
					
				if (current < length - 2) {
					// Right before the harvesting phase
					if (fractionalGrowingTimeCompleted * 100D > getUpperPercent(current)) {
						// Advance onto the next phase
						phaseType = CropConfig.getCropTypeByID(cropTypeID).getPhases().get(current + 1).getPhaseType();
						// currentPhaseWorkCompleted = 0D;
					}
				}

				// check for the passing of each day
				int newSol = marsClock.getMissionSol();
				if (currentSol != newSol) {
					// TODO: what needs to be done at the end of each sol ?
					currentSol = newSol;
					// double maxDailyHarvest = maxHarvest / cropGrowingDay;
//					double w = phases.get(current).getWorkRequired() * 1000D;
//					// Calculate the daily work completed
//					double dailyWorkCompleted = currentPhaseWorkCompleted / w;
//					// Modify actual harvest amount based on daily tending work.
//					dailyHarvest += (dailyMaxHarvest * (dailyWorkCompleted - .5D));
					
					// Resets the daily harvest back to zero
					dailyHarvest = 0;
					
					// Update the resource usage
					updateUsage();

					if (dailyHarvest < 0) {
						phaseType = PhaseType.FINISHED;
						dailyHarvest = 0;
						return;
					}
					// TODO: is it better off doing the actualHarvest computation once a day or
					// every time
					// Reset the daily work counter currentPhaseWorkCompleted back to zero
					// currentPhaseWorkCompleted = 0D;
					cumulativeDailyPAR = 0;
				}

				int msol = marsClock.getMillisolInt();

				if (msolCache != msol && msol % CHECK_HEALTH_FREQUENCY == 0) {
					msolCache = msol;
					// Checks on crop health
					trackHealth();
				}

				// max possible harvest within this period of time
				double maxPeriodHarvest = maxHarvest * (time / growingTime);
				// Compute each harvestModifiers and sum them up below
				double harvestModifier = computeHarvest(maxPeriodHarvest, time);
				// Add to the daily harvest.
				dailyHarvest += maxPeriodHarvest * harvestModifier;
				// Add to the cumulative harvest.				
				remainingHarvest += maxPeriodHarvest * harvestModifier;
				
				if (dailyHarvest < 0) {
					phaseType = PhaseType.FINISHED;
					dailyHarvest = 0;
					return;
				}
			}
			

			if (fractionalGrowingTimeCompleted > 1.1) {
				phaseType = PhaseType.FINISHED;
				totalHarvest = 0;
				return;
			}
			
//		}

		else if (phaseType == PhaseType.FINISHED) {
			dailyHarvest = 0;
			totalHarvest = 0;
			growingTimeCompleted = 0;
		}

	}

	public void turnOnLighting(double kW) {
		lightingPower = kW;
	}

	public void turnOffLighting() {
		lightingPower = 0;
	}

	/**
	 * Computes the effects of the available sunlight and artificial light
	 * 
	 * @param time
	 * @return instantaneous PAR or uPAR
	 */
	public double computeLight(double time) {
		double lightModifier = 0;

		int msols = marsClock.getMillisolInt();
		// Note : The average PAR is estimated to be 20.8 mol/(m² day) (Gertner, 1999)
		// Calculate instantaneous PAR from solar irradiance
		double uPAR = wattToPhotonConversionRatio 
				* surface.getSolarIrradiance(unitManager.getSettlementByID(settlementID).getCoordinates());
		// [umol /m^2 /s] = [u mol /m^2 /s /(Wm^-2)] * [Wm^-2]
		double PAR_interval = uPAR / 1_000_000D * time * MarsClock.SECONDS_PER_MILLISOL; // in mol / m^2 within this
																							// period of time
		// [mol /m^2] = [umol /m^2 /s] / u * [millisols] * [s /millisols]
		// 1 u = 1 micro = 1/1_000_000
		// Note : daily-PAR has the unit of [mol /m^2 /day]
		// Gauge if there is enough sunlight
		double progress = cumulativeDailyPAR / dailyPARRequired; // [max is 1]

		double clock = msols / 1000D; // [max is 1]
		
//		logger.info("uPAR : "+ fmt.format(uPAR) + "\tPAR_interval : " +
//		fmt.format(PAR_interval) + "\tprogress : "+ fmt.format(progress) +
//		 "\truler : " + fmt.format(clock));

		// When enough PAR have been administered to the crop, the HPS_LAMP will turn
		// off.
		// TODO: what if the time zone of a settlement causes sunlight to shine at near
		// the tail end of the currentMillisols time ?
		// Compared cumulativeDailyPAR / dailyPARRequired vs. current time /
		// 1000D
		// Reduce the frequent toggling on and off of lamp and to check on
		// the time of day to anticipate the need of sunlight.
		if (0.5 * progress < clock && msols <= 333 || 0.7 * progress < clock && msols > 333 && msols <= 666
				|| progress < clock && msols > 666) {
			// TODO: also compare also how much more sunlight will still be available
			if (uPAR > 40) { // if sunlight is available
				turnOffLighting();
				cumulativeDailyPAR = cumulativeDailyPAR + PAR_interval;
				// Gets the effectivePAR
				effectivePAR = PAR_interval;
//				 logger.info(cropType.getName() + "\tcumulativeDailyPAR : " +
//				 fmt.format(cumulativeDailyPAR) + "\tdelta_PAR_sunlight : "+
//				 fmt.format(delta_PAR_sunlight));
				 
			}

			else { // if no sunlight, turn on artificial lighting
					// double conversion_factor = 1000D * wattToPhotonConversionRatio /
					// MarsClock.SECONDS_IN_MILLISOL ;
					// DLI is Daily Light Integral is the unit for for cumulative light -- the
					// accumulation of all the PAR received during a day.
				double DLI = dailyPARRequired - cumulativeDailyPAR; // [in mol / m^2 / day]
				double delta_PAR_outstanding = DLI * (time / 1000D) * growingArea;
				// in mol needed at this delta time [mol] = [mol /m^2 /day] * [millisol] /
				// [millisols /day] * m^2
				double delta_kW = delta_PAR_outstanding / time / conversion_factor;
				// [kW] = [mol] / [u mol /m^2 /s /(Wm^-2)] / [millisols] / [s /millisols] = [W
				// /u] * u * k/10e-3 = [kW]; since 1 u = 10e-6
				// TODO: Typically, 5 lamps per square meter for a level of ~1000 mol/ m^2 /s
				// Added PHYSIOLOGICAL_LIMIT sets a realistic limit for tuning how
				// much PAR a food crop can absorb per frame.
				// Note 1 : PHYSIOLOGICAL_LIMIT minimize too many lights turned on and off too
				// frequently
				// Note 2 : It serves to smooth out the instantaneous power demand over a period
				// of time
				// each HPS_LAMP lamp supplies 400W has only 40% visible radiation efficiency
				int numLamp = (int) (Math.ceil(
						delta_kW / kW_PER_HPS / VISIBLE_RADIATION_HPS / (1 - BALLAST_LOSS_HPS) * PHYSIOLOGICAL_LIMIT));
				// TODO: should also allow the use of LED_KIT for lighting
				// For converting lumens to PAR/PPF, see
				// http://www.thctalk.com/cannabis-forum/showthread.php?55580-Converting-lumens-to-PAR-PPF
				// Note: do NOT include any losses below
				double supplykW = numLamp * kW_PER_HPS * VISIBLE_RADIATION_HPS * (1 - BALLAST_LOSS_HPS)
						/ PHYSIOLOGICAL_LIMIT;
				turnOnLighting(supplykW);
				double delta_PAR_supplied = supplykW * time * conversion_factor / growingArea; // in mol / m2
				// [ mol / m^2] = [kW] * [u mol /m^2 /s /(Wm^-2)] * [millisols] * [s /millisols]
				// / [m^2] = k u mol / W / m^2 * (10e-3 / u / k) = [mol / m^-2]
				cumulativeDailyPAR = cumulativeDailyPAR + delta_PAR_supplied + PAR_interval;
				// [mol /m^2 /d]
				
				// Gets the effectivePAR
				effectivePAR = delta_PAR_supplied + PAR_interval;
						
//				 logger.info(cropType.getName() + "\tPAR_outstanding_persqm_daily : " +
//				 fmt.format(PAR_outstanding_persqm_daily) + "\tdelta_PAR_outstanding : " +
//				 fmt.format(delta_PAR_outstanding) + "\tdelta_kW : "+ fmt.format(delta_kW) +
//				 "\tnumLamp : " + numLamp + "\tsupplykW : "+ fmt.format(supplykW) +
//				 "\tdelta_PAR_supplied : "+ fmt.format(delta_PAR_supplied) +
//				 "\tdelta_PAR_sunlight : "+ fmt.format(delta_PAR_sunlight) +
//				 "\tcumulativeDailyPAR : " + fmt.format(cumulativeDailyPAR));
				 
			}
		}

		else {

			turnOffLighting();
			// TODO : move the curtain out to block excessive sunlight		
//			 logger.info(cropType.getName() + "\tcumulativeDailyPAR : " +
//			 fmt.format(cumulativeDailyPAR)); //+ "\tdelta_PAR_sunlight : "+
//			 fmt.format(delta_PAR_sunlight));
		}

		// check for the passing of each day
		int newSol = marsClock.getMissionSol();
		// the crop has memory of the past lighting condition
		lightModifier = cumulativeDailyPAR / (dailyPARRequired + .0001) * 1000D / ( msols  + .0001);
		// TODO: If too much light, the crop's health may suffer unless a person comes
		// to intervene
		if (isStartup && newSol == 1) {
			// if this crop is generated at the start of the sim, 
			// lightModifier should start from 1, rather than 0
			lightModifier = 1;
		}
		
		adjustEnvironmentFactor(lightModifier, 0);

		return uPAR;

	}

	/**
	 * Compute the effect of the temperature
	 */
	public void computeTemperature() {

		double temperatureModifier = 0;
		double t_now = building.getCurrentTemperature();

		if (t_now > (t_initial + T_TOLERANCE))
			temperatureModifier = t_initial / t_now;
		else if (t_now < (t_initial - T_TOLERANCE))
			temperatureModifier = t_now / t_initial;
		else
			// TODO: implement optimal growing temperature for each particular crop
			temperatureModifier = 1D;

		adjustEnvironmentFactor(temperatureModifier, 2);

	}

	/***
	 * Computes the effect of water and fertilizer
	 * 
	 * @param needFactor
	 * @param time
	 */
	public void computeWaterFertilizer(double needFactor, double time) {
		// Calculate water usage kg per sol
		double waterRequired =  TUNING_FACTOR * needFactor * (averageWaterNeeded * time / 1_000D) * growingArea; // fractionalGrowingTimeCompleted
//		System.out.println(getCropType() + "  waterRequired : " + waterRequired);
		// Determine the amount of grey water available.
		double gw = building.getInventory().getAmountResourceStored(greywaterID, false);
		double greyWaterAvailable = Math.min(gw * unitManager.getSettlementByID(settlementID).getGreyWaterFilteringRate() * time, gw);
		double waterUsed = 0;
		double greyWaterUsed = 0;
//		double totalWaterUsed = 0;

		double waterModifier = 0;
		double fertilizerModifier = 0;

		// First water crops with grey water if it is available.
		if (greyWaterAvailable >= waterRequired) {
			greyWaterUsed = waterRequired;
//			totalWaterUsed = greyWaterUsed;
			if (greyWaterUsed > MIN)
				retrieve(greyWaterUsed, greywaterID, true);
			// TODO: track grey water as well ?
			waterModifier = 1D;
		}

		else if (greyWaterAvailable < waterRequired) {
			// If not enough grey water, use water
			greyWaterUsed = greyWaterAvailable;
			if (greyWaterUsed > MIN)
				retrieve(greyWaterUsed, greywaterID, true);
			// TODO: track grey water as well ?
			waterRequired = waterRequired - greyWaterUsed;
			double waterAvailable = building.getInventory().getAmountResourceStored(waterID, false);
			
			if (waterAvailable >= waterRequired) {
				waterUsed = waterRequired;
				if (waterUsed > MIN) {
					retrieve(waterUsed, waterID, true);
					//  Records the daily water usage in the farm
					farm.addDailyWaterUsage(waterUsed);
				}
				
				waterModifier = 1D;
			}
			else {
				// not enough water
				waterUsed = waterAvailable;
				if (waterUsed > MIN) {
					retrieve(waterUsed, waterID, true);
					//  Records the daily water usage in the farm
					farm.addDailyWaterUsage(waterUsed);
				}
				// Incur penalty if water is NOT available
				// need to add .0001 in case waterRequired becomes zero
				waterModifier = (greyWaterUsed + waterUsed) / (waterRequired + .0001);
			}

			double fertilizerAvailable = building.getInventory().getAmountResourceStored(fertilizerID, false);
			// The amount of fertilizer to be used depends on the ratio of the grey water used
			double fertilizerRequired = FERTILIZER_NEEDED_WATERING * time * greyWaterUsed / (greyWaterUsed + waterUsed + .0001);
			double fertilizerUsed = fertilizerRequired;

			if (fertilizerUsed > fertilizerAvailable) {
				// not enough fertilizer
				fertilizerUsed = fertilizerAvailable;
				// should incur penalty due to insufficient fertilizer
				fertilizerModifier = fertilizerUsed / ( fertilizerRequired + 0.0001);
			} else {
				// there's enough fertilizer
				fertilizerModifier = 1D;
			}

			if (fertilizerUsed > MIN) {
				retrieve(fertilizerUsed, fertilizerID, true);
			}

			adjustEnvironmentFactor(fertilizerModifier, 1);

		}

		// Amount of water reclaimed through a Moisture Harvesting System inside the
		// Greenhouse
		// TODO: Modify harvest modifier according to the moisture level
		// double waterReclaimed = totalWaterUsed * growingArea * time / 1000D *
		// MOISTURE_RECLAMATION_FRACTION;
		// if (waterReclaimed > 0)
		// Storage.storeAnResource(waterReclaimed, waterID, inv, sourceName +
		// "::computeWaterFertilizer");

		// Assume an universal rate of water vapor evaporation rate of 5%
		// farm.addMoisture(totalWaterUsed*.05);
		// Record the amount of water taken up by the crop
		cumulative_water_usage = cumulative_water_usage + waterUsed;// * .95;

		adjustEnvironmentFactor(waterModifier, 3);

	}

	/***
	 * Computes the effects of the concentration of O2 and CO2
	 * 
	 * @param uPAR
	 * @param needFactor
	 * @param maxPeriodHarvest
	 * @param time
	 */
	public void computeGases(double uPAR, double needFactor, double time) {
		double watt = uPAR / time / conversion_factor * growingArea * 1000; 
//		System.out.println("uPAR : " + uPAR + "  Watt : " + watt);
		// Note: uPAR includes both sunlight and artificial light
		// Calculate O2 and CO2 usage kg per sol
		double o2Modifier = 0, co2Modifier = 0;
		double fudge_factor = 0;

		if (watt < 40) {
//			if (uPAR == 0)
				fudge_factor = 2.5;
//			else if (uPAR == 40)
//				fudge_factor = 2.5;
//			else
//				fudge_factor = 5 - 2.5 * uPAR / 40;
//			
//			if (fudge_factor < 0)
//				fudge_factor = 0;
			
			double o2Required = fractionalGrowingTimeCompleted * fudge_factor * needFactor
					* (averageOxygenNeeded * time / 1000) * growingArea;
			double o2Available = building.getInventory().getAmountResourceStored(oxygenID, false);
			double o2Used = o2Required;

			o2Modifier = o2Available / o2Required;

			if (o2Used > o2Available)
				o2Used = o2Available;
			if (o2Used > MIN) {
				retrieve(o2Used, oxygenID, true);
				// farm.addO2Cache(-o2Used);
				cumulative_o2 = cumulative_o2 - o2Used;
			}

//			o2Modifier = o2Used / o2Required;

			adjustEnvironmentFactor(o2Modifier, 4);

			// Determine the amount of co2 generated via gas exchange.
			double cO2Gen = o2Used * CO2_TO_O2_RATIO;
			if (cO2Gen > MIN) {
				store(cO2Gen, carbonDioxideID, sourceName + "::computeGases");
				// farm.addCO2Cache(cO2Gen);
				cumulative_co2 = cumulative_co2 + cO2Gen;
			}

//			if (o2Required != 0) 
//				System.out.print("o2Required: " + Math.round(o2Required*100_000.0)/100_000.0);
//			if (cO2Gen != 0) 
//				System.out.println(" cO2Gen: " + Math.round(cO2Gen*100_000.0)/100_000.0);
		}

		else {
			// during the day
			fudge_factor = .0185 * watt + 1.76;
			// TODO: gives a better modeling of how the amount of light available will
			// trigger photosynthesis that converts co2 to o2
			// Determine harvest modifier by amount of carbon dioxide available.
			double cO2Req = fractionalGrowingTimeCompleted * fudge_factor * needFactor
					* (averageCarbonDioxideNeeded * time / 1000) * growingArea;
			double cO2Available = building.getInventory().getAmountResourceStored(carbonDioxideID, false);
			double cO2Used = cO2Req;

			// TODO: allow higher concentration of co2 to be pumped to increase the harvest
			// modifier to the harvest.

			co2Modifier = cO2Available / cO2Req;
			
			if (cO2Used > cO2Available)
				cO2Used = cO2Available;
			if (cO2Used > MIN) {
				retrieve(cO2Used, carbonDioxideID, true);
				// farm.addCO2Cache(-cO2Used);
				cumulative_co2 = cumulative_co2 - cO2Used;
			}
			// TODO: research how much high amount of CO2 may facilitate the crop growth and
			// reverse past bad health

//			co2Modifier = cO2Used / cO2Req;

			adjustEnvironmentFactor(co2Modifier, 5);

			// 6CO2 + 6H2O + sunlight -> C6H12O6 + 6O2
			//
			// Determine the amount of oxygen generated during the day when photosynthesis
			// is taking place .
			double o2Gen = cO2Used * O2_TO_CO2_RATIO;
//			System.out.println("cO2Used : " + cO2Used);
			if (o2Gen > 0) {
				store(o2Gen, oxygenID, sourceName + "::computeGases");
				// farm.addO2Cache(o2Gen);
				cumulative_o2 = cumulative_o2 + o2Gen;
			}

//			if (cO2Used != 0) 
//				System.out.print("cO2Used: " + Math.round(cO2Used*100_000.0)/100_000.0);
//			if (o2Gen != 0) 
//				System.out.println(" o2Gen: " + Math.round(o2Gen*100_000.0)/100_000.0);
		}

	}

	/**
	 * Adjust the environmental factors
	 * 
	 * @param mod the modifier of interest
	 * @param type the 
	 */
	public void adjustEnvironmentFactor(double mod, int type) {
		double f = environmentalFactor[type];
		f = 0.01 * mod + 0.99 * f;
		if (f > 1.25)
			f = 1.25;	
		else if (f < 0.1 || Double.isNaN(f))
			f = 0.1;
		environmentalFactor[type] = f;
	}
	
	/**
	 * Computes each input and output constituent for a crop for the specified
	 * period of time and return the overall harvest modifier
	 * 
	 * @param the maximum possible growth/harvest
	 * @param a   period of time in millisols
	 * @return the harvest modifier
	 */
	public double computeHarvest(double maxPeriodHarvest, double time) {

		double harvestModifier = 1D;

		// TODO: use theoretical model for crop growth, instead of empirical model
		// below.
		// TODO: the calculation should be uniquely tuned to each crop
		// TODO: Modify harvest modifier according to the pollination by the number of
		// bees in the greenhouse
		// TODO: Modify harvest modifier by amount of artificial light available to the
		// whole greenhouse

		int phaseNum = getCurrentPhaseNum();
		int length = phases.size();

		// Tune the growthFactor according to the stage of a crop
		double growthFactor = 5;
		// amount of grey water/water needed is also based on % of growth
		if (phaseNum == 2)
			// if (phaseType == PhaseType.GERMINATION)
			growthFactor = .2;
		else if (fractionalGrowingTimeCompleted < .1)
			growthFactor = .3;
		else if (fractionalGrowingTimeCompleted < .15)
			growthFactor = .4;
		else if (fractionalGrowingTimeCompleted < .2)
			growthFactor = .5;
		else if (phaseNum > 2 && phaseNum < length - 2)
			growthFactor = fractionalGrowingTimeCompleted;
		else if (phaseType == PhaseType.FINISHED)
			growthFactor = .4;

		// STEP 1 : COMPUTE THE EFFECTS OF THE SUNLIGHT AND ARTIFICIAL LIGHT
		double uPAR = 0;

		if (cropCategoryType == CropCategoryType.FUNGI) {// cropName.contains("mushroom")) {
			environmentalFactor[0] = 1D;
			// Set uPAR to zero since mushrooms are fungi, neeed no sunlight
			// Fungi consumes O2 and release CO2
			uPAR = 0;
		} else {
			uPAR = computeLight(time);
		}
		
		// STEP 2 : COMPUTE THE EFFECTS OF THE TEMPERATURE
		computeTemperature();

		// STEP 3 : COMPUTE THE EFFECTS OF THE WATER AND FERTIZILER
		computeWaterFertilizer(growthFactor, time);

		// STEP 4 : COMPUTE THE EFFECTS OF GASES (O2 and CO2 USAGE)
		computeGases(effectivePAR, growthFactor, time);
		// Note that mushrooms are fungi and consume O2 and release CO2

		// TODO: add air pressure modifier in future

		// Tune harvestModifier
		// Note that light is the dorminant environmental factor
		if (phaseNum > 2 && phaseNum < length - 2) {
			harvestModifier = .6 * harvestModifier + .4 * harvestModifier * environmentalFactor[0];
		} else if (phaseNum == 2)
			harvestModifier = .8 * harvestModifier + .2 * harvestModifier * environmentalFactor[0];

		harvestModifier = .25 * harvestModifier + .15 * harvestModifier * environmentalFactor[1]
				+ .15 * harvestModifier * environmentalFactor[2] + .15 * harvestModifier * environmentalFactor[3]
				+ .15 * harvestModifier * environmentalFactor[4] + .15 * harvestModifier * environmentalFactor[5];

		// TODO: research how the above 6 factors may affect crop growth for different
		// crop categories

		return harvestModifier;
	}

	/**
	 * Gets the average growing time for a crop.
	 * 
	 * @return average growing time (millisols)
	 * @throws Exception if error reading crop config.
	 */
	public static double getAverageCropGrowingTime() {
		return CropConfig.getAverageCropGrowingTime();
	}

	public int getCurrentPhaseNum() {
		for (Entry<Integer, Phase> entry : phases.entrySet()) {
			if (entry.getValue().getPhaseType() == phaseType) {
				return entry.getKey();
			}
		}
		return -1;
	}

	/**
	 * Gets the upper limit percentage of the phase
	 */
	public double getUpperPercent(int phase) {
		double result = 0;
		for (int i = 1; i < phase + 1; i++) {
			if (phases.get(i) != null)
				result = result + phases.get(i).getPercentGrowth();
		}
		return result;
	}

	public Map<Integer, Phase> getPhases() {
		return phases;
	}

	public void resetPAR() {
		cumulativeDailyPAR = 0;
	}

	public double getHealthCondition() {
		return healthCondition;
	}

	public double getPercentGrowth() {
		return  Math.round(fractionalGrowingTimeCompleted * 1_000.0)/10.0;
	}

	public int getIdentifier() {
		return identifier;
	}
	
	public boolean retrieve(double amount, int resource, boolean value) {
		return Storage.retrieveAnResource(amount, resource, building.getInventory(), value);
	}
	
	public void store(double amount, int resource, String source) {
		Storage.storeAnResource(amount, resource, building.getInventory(), source);
	}
	
	public boolean equals(Object obj) {
		if (this == obj) return true;
		if (obj == null) return false;
		if (this.getClass() != obj.getClass()) return false;
		Crop c = (Crop) obj;
		return this.identifier == c.getIdentifier();
	}
	
	/**
	 * Reloads instances after loading from a saved sim
	 * 
	 * @param {@link MasterClock}
	 * @param {{@link MarsClock}
	 */
	public static void initializeInstances(MasterClock c0, MarsClock c1, SurfaceFeatures sf, UnitManager u) {
		masterClock = c0;
		marsClock = c1;
		surface = sf;
		cropConfig = SimulationConfig.instance().getCropConfiguration();
		unitManager = u;
	}
	
	/**
	 * Prepare object for garbage collection.
	 */
	public void destroy() {
		phaseType = null;
		cropCategoryType = null;
		farm = null;
		surface = null;
		marsClock = null;
		masterClock = null;
		phases = null;

	}
}
